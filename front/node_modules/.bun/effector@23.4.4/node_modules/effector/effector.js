var m1=Object.create;var{getPrototypeOf:l1,defineProperty:R1,getOwnPropertyNames:f1}=Object;var p1=Object.prototype.hasOwnProperty;var E2=(D,F,I)=>{I=D!=null?m1(l1(D)):{};let Z=F||!D||!D.__esModule?R1(I,"default",{value:D,enumerable:!0}):I;for(let K of f1(D))if(!p1.call(Z,K))R1(Z,K,{get:()=>D[K],enumerable:!0});return Z};var O2=(D,F)=>()=>(F||D((F={exports:{}}).exports,F),F.exports);function o(D,F){for(let I in D)F(D[I],I)}function v(D,F){D.forEach(F)}function M(D,F,I){if(!D)throw Error(`${I?I+": ":""}${F}`)}function u1(D,F){let I=L(D),Z=I.meta||{};Y0(D)||(Z.isRegion=1),y={id:I.id,parent:y,value:D,template:Z.template||X0(),sidRoot:Z.sidRoot||y&&y.sidRoot,meta:Z};try{return F()}finally{K1("region"),y=b(y)}}function P({node:D=[],from:F,source:I,parent:Z=F||I,to:K,target:E,child:O=K||E,scope:C={},meta:W={},family:j={type:"regular"},regional:Q}={}){let A=N0(Z),_=N0(j.links),N=N0(j.owners),B=[];v(D,(V)=>V&&G(B,V));let R={id:o1(),seq:B,next:N0(O),meta:W,scope:C,family:{triggers:A.length,type:j.type||"crosslink",links:_,owners:N}};return v(_,(V)=>G(V0(V),R)),v(N,(V)=>G(H0(V),R)),v(A,(V)=>G(V.next,R)),Q&&y&&t(J0(y),[R]),R}function r(D,F,I){let Z,K=s,E=null,O=x;if(D.target&&(F=D.params,I=D.defer,Z=D.meta,K=("page"in D)?D.page:K,D.stack&&(E=D.stack),O=I0(D)||O,D=D.target),O&&x&&O!==x&&(x=null),Array.isArray(D))for(let B=0;B<D.length;B++)C0("pure",K,L(D[B]),E,F[B],O,Z);else C0("pure",K,L(D),E,F,O,Z);if(I&&!g0)return;let C={isRoot:g0,currentPage:s,scope:x,isWatch:v0,isPure:L0},W,j,Q,A,_,N;g0=0;D:for(;A=t1();){let{idx:B,stack:R,type:V}=A;Q=R.node,s=_=R.page,x=I0(R),_?N=_.reg:x&&(N=x.reg);let X=!!_,J=!!x,U={fail:0,scope:Q.scope};W=j=0;for(let q=B;q<Q.seq.length&&!W;q++){let z=Q.seq[q];if(z.order){let{priority:Y,barrierID:H}=z.order,g=H?_?`${_.fullID}_${H}`:H:0;if(q!==B||V!==Y){H?f0.has(g)||(f0.add(g),o0(q,R,Y,H)):o0(q,R,Y,0);continue D}H&&f0.delete(g)}switch(z.type){case"mov":{let H=z.data,g;switch(H.from){case"stack":g=J0(R);break;case"a":case"b":g=R[H.from];break;case"value":g=H.store;break;case"store":if(N&&!N[H.store.id])if(X){let Q0=$1(_,H.store.id);R.page=_=Q0,Q0?N=Q0.reg:J?(R0(x,H.store,0,1,H.softRead),N=x.reg):N=void 0}else J&&R0(x,H.store,0,1,H.softRead);g=q0(N&&N[H.store.id]||H.store)}switch(H.to){case"stack":R.value=g;break;case"a":case"b":R[H.to]=g;break;case"store":n0(_,x,H.target,0).current=g}break}case"compute":let Y=z.data;if(Y.fn){v0=Q.meta.op==="watch",L0=Y.pure;let H=Y.safe?(0,Y.fn)(J0(R),U.scope,R):D2(U,Y.fn,R);Y.filter?j=!H:R.value=H,v0=C.isWatch,L0=C.isPure}}W=U.fail||j}if(r0&&r0(R,U),!W){let q=J0(R),z=I0(R);if(v(Q.next,(Y)=>{C0("child",_,Y,R,q,z)}),z){Q.meta.needFxCounter&&C0("child",_,z.fxCount,R,q,z),Q.meta.storeChange&&C0("child",_,z.storeChange,R,q,z),Q.meta.warnSerialize&&C0("child",_,z.warnSerializeNode,R,q,z);let Y=z.additionalLinks[Q.id];Y&&v(Y,(H)=>{C0("child",_,H,R,q,z)})}}}g0=C.isRoot,s=C.currentPage,x=I0(C)}function Y1(D,F="combine"){let I=F+"(",Z="",K=0;return o(D,(E)=>{K<25&&(E!=null&&(I+=Z,I+=u(E)?h0(E).fullName:E.toString()),K+=1,Z=", ")}),I+")"}function j2(D,F){D.shortName=F,Object.assign(h0(D),t0(F,b(D)))}function t0(D,F){let I,Z,K=D;if(F){let E=h0(F);D.length===0?(I=E.path,Z=E.fullName):(I=E.path.concat([D]),Z=E.fullName.length===0?D:E.fullName+"/"+D)}else I=D.length===0?[]:[D],Z=D;return{shortName:K,fullName:Z,path:I}}function T(D,F){if(!F)return D;if(!F.name&&!F.named&&!F.loc)return D;let I=`[${D}]`,Z=F.named||F.name;Z&&(I+=` unit '${Z}'`);let K=F.loc;return!Z&&K&&(I+=` (${K.file}:${K.line}:${K.column})`),I}function E0(D,F){let I=F?D:D[0];Z1(I);let{or:Z,and:K}=I;if(K){let E=F?K:K[0];if(d(E)&&"and"in E){let O=E0(K,F);D=O[0],Z={...Z,...O[1]}}else D=K}return[D,Z]}function d0(D){let F=()=>D();return F.unsubscribe=()=>D(),F}function f(D,...F){let I=X0();if(I){let Z=I.handlers[D];if(Z)return Z(I,...F)}}function w(D,F){let I=Z0({or:F,and:typeof D=="string"?{name:D}:D}),Z=T("event",I),K=(C,...W)=>(M(!S(K,"derived"),"call of derived event is not supported, use createEvent instead",Z),M(!L0,"unit call from pure function is not supported, use operators like sample instead",Z),s?((j,Q,A,_)=>{let N=s,B=null;if(Q)for(B=s;B&&B.template!==Q;)B=b(B);U1(B);let R=j.create(A,_);return U1(N),R})(K,E,C,W):K.create(C,W)),E=X0(),O=Object.assign(K,{graphite:P({meta:W1(I.actualOp||"event",K,I,O0(w)),regional:1}),create:(C)=>(r({target:K,params:C,scope:x}),C),watch:(C)=>k1(K,C),map:(C)=>p0(K,W0,C,[n()]),filter:(C)=>p0(K,"filter",C.fn?C:C.fn,[n(m0,1)]),filterMap:(C)=>p0(K,"filterMap",C,[n(),$((W)=>!l(W),1)]),prepend(C){M(K.targetable,".prepend of derived event is not supported, call source event instead",Z);let W=w("* → "+K.shortName,{parent:b(K)});return f("eventPrepend",L(W)),e(W,K,[n()],"prepend",C),_1(K,W),W}});return I!=null&&I.domain&&I.domain.hooks.event(O),m(O,"id",O.graphite.id),K1(O.graphite),O}function X1(D,F,I,Z,K){return B0(I,`${K} ${F}`,"first argument"),M(h(Z),"second argument should be a function",K),i(!S(D,"derived"),`${F} in derived store`,`${F} in store created via createStore`,K),v(Array.isArray(I)?I:[I],(E)=>{D.off(E),y1(E,D,"on",n1,Z)}),D}function K0(D,F){let I=Z0(F),Z=A0(D),K=T("store",I),E=w({named:"updates",derived:1});f("storeBase",Z);let O=Z.id,C="skipVoid"in I,W=C&&!I.skipVoid;i(!(C&&I.skipVoid),"{skipVoid: true}","updateFilter",K);let j={updates:E,defaultState:D,stateRef:Z,getState(){let X,J=Z;if(s){let U=s;for(;U&&!U.reg[O];)U=b(U);U&&(X=U)}return!X&&x&&(R0(x,Z,1),X=x),X&&(J=X.reg[O]),q0(J)},setState:(X)=>r({target:j,params:X,defer:1,scope:x}),reset:(...X)=>(M(j.targetable,".reset of derived store is not supported",K),v(X,(J)=>X1(j,".reset",J,()=>j.defaultState,K)),j),on:(X,J)=>(M(j.targetable,".on of derived store is not supported",K),X1(j,".on",X,J,K)),off(X){let J=L(X).id,U=L(j).family.links.find((q)=>q.meta.onTrigger===J);return U&&w0(U),j},map(X,J){let U,q;d(X)&&(U=X,X=X.fn);let z=j.getState(),Y=l(z);X0()?q=null:(!Y||Y&&W)&&(q=X(z));let H=K0(q,{name:`${j.shortName} → *`,derived:1,...J,and:U}),g=y1(j,H,W0,m0,X);return $0(p(H),{type:W0,fn:X,from:Z}),p(H).noInit=1,f("storeMap",Z,g),H},watch(X,J){if(i(!J,"watch second argument","sample",K),!J||!u(X)){let U=k1(j,X);return f("storeWatch",Z,X)||X(j.getState()),U}return M(h(J),"second argument should be a function",K),X.watch((U)=>J(j.getState(),U))}},Q=W1("store",j,I,O0(K0)),A=j.defaultConfig.updateFilter;j.graphite=P({scope:{state:Z,fn:A},node:[$((X,J,U)=>(U.scope&&!U.scope.reg[Z.id]&&(U.b=1),X)),a(Z),$((X,J,{a:U,b:q})=>{let z=l(X);return z&&!C&&G1(`${P0}`,j.graphite),(z&&W||!z)&&(X!==U||q)},1),A&&n(S1,1),c({from:"stack",target:Z})],child:E,meta:{...Q,defaultState:D,stateRef:Z},regional:1}),m(j,"id",j.graphite.id),m(j,"rootStateRefId",O);let _=S(j,"serialize"),N=S(j,"derived"),B=_==="ignore",R=S(j,"sid");R&&(m(j,"storeChange",1),Z.sid=R),R||B||N||m(j,"warnSerialize",1);let V=l(D);return M(N||!V||V&&W,P0,K),N&&V&&!C&&console.error(`${K}: ${P0}`),t(j,[E]),I!=null&&I.domain&&I.domain.hooks.store(j),N||(j.reinit=w({named:"reinit"}),j.reset(j.reinit)),Z.meta=j.graphite.meta,K1(j.graphite),j}function e0(...D){let F,I,Z;[D,Z]=E0(D);let K=T("combine",Z),E=D[D.length-1],O=D.length>1&&!k(E)&&d(E),C=O&&E,W=O?D[D.length-2]:E,j,Q,A;if(h(W)?(I=D.slice(0,O?-2:-1),F=W):I=D,I.length===1){let _=I[0];k(_)||(j=_,Q=1)}if(!Q&&(j=I,F)){A=1;let _=F;F=(N)=>_(...N)}return M(d(j),`${K}: shape should be an object`),F2(Array.isArray(j),!A,j,O0(e0),Z,F,C)}function M1(){let D={};return D.req=new Promise((F,I)=>{D.rs=F,D.rj=I}),D.req.catch(()=>{}),D}function D1(D,F={}){let I=Z0(h(D)?{handler:D}:D,F),Z=T("effect",I),K=w(h(D)?{handler:D}:D,{...F,actualOp:"effect"});M0(K,O0(D1));let E=L(K);m(E,"op",K.kind="effect"),K.use=(B)=>(M(h(B),".use argument should be a function",Z),A.scope.handler=B,K),K.use.getCurrent=()=>A.scope.handler;let O=K.finally=w({named:"finally",derived:1}),C=K.done=O.filterMap({named:"done",fn({status:B,params:R,result:V}){if(B==="done")return{params:R,result:V}}}),W=K.fail=O.filterMap({named:"fail",fn({status:B,params:R,error:V}){if(B==="fail")return{params:R,error:V}}}),j=K.doneData=C.map({named:"doneData",fn:({result:B})=>B}),Q=K.failData=W.map({named:"failData",fn:({error:B})=>B}),A=P({scope:{handler:K.defaultConfig.handler||(()=>M(0,`no handler used in ${K.compositeName.fullName}`))},node:[$((B,R,V)=>{let X=R.handler,J=I0(V);if(J){let U=J.handlers.unitMap.get(K)||J.handlers.sidMap[K.sid];U&&(X=U)}return B.handler=X,B},0,1),$((B,R,V)=>{if(R.runnerFn&&!R.runnerFn(B,null,V))return;let{params:X,req:J,handler:U,args:q=[X]}=B,z=y0(X,J,1,O,V),Y=y0(X,J,0,O,V),[H,g]=h1(U,Y,q);H&&(d(g)&&h(g.then)?g.then(z,Y):z(g))},0,1)],meta:{op:"fx",fx:"runner"},regional:1});E.scope.runner=A,G(E.seq,$((B,{runner:R},V)=>{let X=b(V)?{params:B,req:{rs(J){},rj(J){}}}:B;return V.meta||(V.meta={fxID:a1()}),r({target:R,params:X,defer:1,scope:I0(V),meta:V.meta}),X.params})),K.create=(B)=>{let R=M1(),V={params:B,req:R};if(x&&!v0){let X=x;R.req.finally(()=>{k0(X)}).catch(()=>{})}return r({target:K,params:V,scope:x}),R.req};let _=K.inFlight=K0(0,{serialize:"ignore",named:(S(K,"name")||K.graphite.id)+".inFlight"}).on(K,(B)=>B+1).on(O,(B)=>B-1).map({fn:(B)=>B,named:"inFlight"});m(O,"needFxCounter","dec"),m(K,"needFxCounter",1);let N=K.pending=_.map({fn:(B)=>B>0,named:"pending"});return t(K,[O,C,W,j,Q,N,_]),I!=null&&I.domain&&I.domain.hooks.effect(K),K}function b1(D){let F;[D,F]=E0(D,1);let I=T("attach",F),{source:Z,effect:K,mapParams:E,domain:O}=D;F0(K)&&M(l(O),"`domain` can only be used with a plain function",I);let C=D1(D,F);m(C,"attached",1),M0(C,O0(b1));let{runner:W}=L(C).scope,j,Q=(_,N,B)=>{let{params:R,req:V,handler:X}=_,J=C.finally,U=y0(R,V,0,J,B),q=B.a,z=F0(X),Y,H=1;if(E?[H,Y]=h1(E,U,[R,q]):Y=Z&&z?q:R,H){if(!z)return _.args=[q,Y],1;r({target:X,params:{params:Y,req:{rs:y0(R,V,1,J,B),rj:U}},page:B.page,defer:1,meta:B.meta})}};if(Z){let _;W.scope.runnerFn=Q,k(Z)?(_=Z,t(_,[C])):(_=e0(Z),t(C,[_])),j=[$((N)=>N,0,1),a(p(_))],delete W.seq[1].order}else j=[$(Q,1,1)];W.seq.splice(1,0,...j),C.use(K);let A=b(K);return A&&(Object.assign(h0(C),t0(C.shortName,A)),C.defaultConfig.parent=A),_1(K,C,"effect"),C}function A2(...D){let[[F,I],Z]=E0(D),K={};return o(I,(E,O)=>{let C=K[O]=w(O,{parent:b(F),config:Z});F.on(C,E),_1(F,C)}),K}function Q1(D,F){let I=Z0({or:F,and:typeof D=="string"?{name:D}:D}),Z=P({family:{type:"domain"},regional:1,parent:(I==null?void 0:I.domain)||(I==null?void 0:I.parent)}),K={history:{},graphite:Z,hooks:{}};Z.meta=W1("domain",K,{parent:(I==null?void 0:I.domain)||(I==null?void 0:I.parent),or:{...I,derived:1}},O0(Q1)),o({Event:w,Effect:D1,Store:K0,Domain:Q1},(O,C)=>{let W=C.toLowerCase(),j=w({named:`on${C}`});K.hooks[W]=j;let Q=new Set;K.history[`${W}s`]=Q,j.create=(A)=>(r(j,A),A),G(L(j).seq,$((A,_,N)=>(N.scope=null,A))),j.watch((A)=>{t(K,[A]),Q.add(A),A.ownerSet||(A.ownerSet=Q),b(A)||(A.parent=K)}),t(K,[j]),K[`onCreate${C}`]=(A)=>(v(Q,A),j.watch(A)),K[`create${C}`]=K[W]=(A,_)=>{let N=Z0({and:_,or:A});return N!=null&&N.domain?O(A,_):j(O(A,{parent:K,or:N}))}});let E=b(K);return E&&o(K.hooks,(O,C)=>e(O,E.hooks[C])),I!=null&&I.domain&&I.domain.hooks.domain(K),K}function _2(D){Z1(D);let F=s0 in D?D[s0]():D;M(F.subscribe,"expect observable to have .subscribe");let I=w(),Z=A1(I);return F.subscribe({next:I,error:Z,complete:Z}),I}function g1(D,F){let I=0;return v(K2,(Z)=>{Z in D&&(M(D[Z]!=null,T1(F,Z)),I=1)}),I}function d1(...D){let F,I,Z,K,[[E,O,C],W]=E0(D),j=1,Q=T("sample",W);return l(O)&&d(E)&&g1(E,Q)&&(O=E.clock,C=E.fn,("batch"in E)?j=E.batch:(i(!("greedy"in E),"greedy in sample","batch",Q),j=!E.greedy),K=E.filter,F=E.target,I=E.name,Z=E.sid,E=E.source),B1("sample",O,E,K,F,C,I,W,j,1,0,Z)}function W2(...D){let[[F,I],Z]=E0(D),K=T("guard",Z);return i(0,"guard","sample",K),I||(I=F,F=I.source),g1(I,K),B1("guard",I.clock,F,I.filter,I.target,null,I.name,Z,!I.greedy,0,1)}function B2(D,F){let I=T("merge",F);B0(D,I,"first argument");let Z=w({name:Y1(D,"merge"),derived:1,and:F});return e(D,Z,[],"merge"),Z}function R2(D,F,I){let Z=T("restore",I);if(M(!k(D),"restore($store) is not supported",Z),F1(D)||F0(D)){let E=b(D),O=K0(F,{parent:E,name:D.shortName,and:I});return e(F0(D)?D.doneData:D,O),E&&E.hooks.store(O),O}let K=Array.isArray(D)?[]:{};return o(D,(E,O)=>K[O]=k(E)?E:K0(E,{name:O})),K}function c1(...D){let I,Z,[[K,E],O]=E0(D),C=T("split",O),W=!E;W&&(I=K.cases,E=K.match,Z=K.clock,K=K.source);let j=k(E),Q=!u(E)&&h(E),A=!j&&!Q&&d(E);M(u(K),"source must be a unit",C),I||(I={}),W?o(I,(X,J)=>E1(C,X,`cases.${J}`)):(M(A,"match should be an object",C),o(E,(X,J)=>I[J]=w({derived:1,named:`cases.${J}`,and:O})),I.__=w({derived:1,named:"cases.__",and:O}));let _=new Set([].concat(K,Z||[],Object.values(I))),N=Object.keys(j||Q?I:E),B,R;if(j||Q)j&&_.add(E),B=[j&&a(p(E),0,1),j0({safe:j,filter:1,pure:!j,fn(X,J,U){let q=String(j?U.a:E(X));b0(J,D0(N,q)?q:"__",X,U)}})];else if(A){let X=R=A0({});X.type="shape";let J=[],U;o(E,(q,z)=>{if(u(q)){U=1,G(J,z),_.add(q);let Y=e(q,[],[a(X),$((H,g,{a:Q0})=>Q0[z]=H)]);if(k(q)){X.current[z]=q.getState();let H=p(q);$0(X,{from:H,field:z,type:"field"}),f("splitMatchStore",H,Y)}}}),U&&f("splitBase",X),B=[U&&a(X,0,1),n((q,z,Y)=>{for(let H=0;H<N.length;H++){let g=N[H];if(D0(J,g)?Y.a[g]:E[g](q))return void b0(z,g,q,Y)}b0(z,"__",q,Y)},1)]}else M(0,"expect match to be unit, function or object");let V=P({meta:{op:"split",stateRef:R},parent:Z?[]:K,scope:I,node:B,family:{owners:Array.from(_)},regional:1});if(Z&&B1("split",Z,K,null,V,null,"split",O,0,0,0),M0(V,O0(c1)),!W)return I}function X2(D,{scope:F,params:I}={}){if(!u(D))return Promise.reject(Error("first argument should be unit"));if(!(F0(D)||F1(D)||k(D)||U0(D)))return Promise.reject(Error("first argument accepts only effects, events, stores or scopes"));if(U0(D))F=D;else if(!I1(D)){let C=T("allSettled",L(D).meta);return Promise.reject(Error(`${C}: unit should be targetable`))}let Z=M1();Z.parentFork=x;let{fxCount:K}=F;G(K.scope.defers,Z);let E=[],O=[];return U0(D)||(G(E,D),G(O,F0(D)?{params:I,req:{rs(C){Z.value={status:"done",value:C}},rj(C){Z.value={status:"fail",value:C}}}}:I)),G(E,K),G(O,null),r({target:E,params:O,scope:F}),Z.req}function x1(D,F,I){let Z=[];(function K(E){D0(Z,E)||(G(Z,E),S(E,"op")==="store"&&(I||S(E,"sid"))&&F(E,S(E,"sid")),v(E.next,K),v(V0(E),K),v(H0(E),K))})(D)}function c0(D,F){let I=Array.isArray(D)?new Map(D):D,Z=new Map,K=0;if(I instanceof Map){let E={};return v(I,(O,C)=>{M(u(C),"Map key should be a unit"),F&&F(C,O),C.sid&&((C.sid in E)&&(K=1),E[C.sid]=O),Z.set(C,O)}),{sidMap:E,unitMap:Z,hasSidDoubles:K}}return{sidMap:I,unitMap:Z}}function Q2(D,F){let I,Z=D;Y0(D)&&(i(0,"fork(domain)","fork()"),I=D,Z=F);let K=((E)=>{let O=P({scope:{defers:[],inFlight:0,fxID:0},node:[$((Q,A,_)=>{_.parent?_.parent.node.meta.needFxCounter==="dec"?A.inFlight-=1:(A.inFlight+=1,A.fxID+=1):A.fxID+=1}),j0({priority:"sampler",batch:1}),$((Q,A)=>{let{defers:_,fxID:N}=A;A.inFlight>0||_.length===0||Promise.resolve().then(()=>{A.fxID===N&&v(_.splice(0,_.length),(B)=>{k0(B.parentFork),B.rs(B.value)})})},0,1)]}),C=P({node:[$((Q,A,_)=>{let N=_.parent;if(N){let B=N.node;if(z1(N)){let R=I0(_),V=B.meta.sid;R.sidIdMap[V]=B.scope.state.id,R.values.sidMap[V]=Q;let X=B.meta.serialize;X&&R.sidSerializeSettings.set(V,X==="ignore"?{ignore:1}:{ignore:0,write:X.write})}}})]}),W=P({node:[$((Q,A,_)=>{let N=I0(_),B=_.parent;N&&B&&z1(B)&&N.warnSerializeNodes.add(B.node)})]}),j={cloneOf:E,reg:{},values:{sidMap:{},idMap:{}},sidIdMap:{},sidSerializeSettings:new Map,getState(Q){if("current"in Q)return n0(s,j,Q,0).current;let A=L(Q);return n0(s,j,A.scope.state,1).current},kind:"scope",graphite:P({family:{type:"domain",links:[O,C,W]},meta:{unit:"fork"},scope:{forkInFlightCounter:O}}),additionalLinks:{},handlers:{sidMap:{},unitMap:new Map},fxCount:O,storeChange:C,warnSerializeNodes:new Set,warnSerializeNode:W};return j})(I);if(Z){if(Z.values){let{sidMap:E,unitMap:O,hasSidDoubles:C}=c0(Z.values,(W)=>M(k(W)&&I1(W),"Values map can contain only writable stores as keys"));Object.assign(K.values.sidMap,E),v(O,(W,j)=>{if(K.values.idMap[j.stateRef.id]=W,K.sidIdMap[S(j,"sid")]=j.stateRef.id,S(j,"serialize")==="ignore"){let Q=S(j,"sid");K.sidSerializeSettings.set(Q,{ignore:1})}}),K.fromSerialize=!(Array.isArray(Z.values)||Z.values instanceof Map),K.hasSidDoubles=C}Z.handlers&&(i(Z.handlers instanceof Map||Array.isArray(Z.handlers),"object with handlers","array"),K.handlers=c0(Z.handlers,(E)=>M(F0(E),"Handlers map can contain only effects as keys")))}return K}function N2(D,{values:F}){M(d(F),"values property should be an object");let{sidMap:I,unitMap:Z}=c0(F),K=Object.getOwnPropertyNames(I),E={};v(Z,(A,_)=>{E[_.stateRef.id]=_});let O=[],C=[],W,j,Q;U0(D)?(W=D,Q=1,M(W.cloneOf,"scope should be created from domain"),i(0,"hydrate(fork(domain), { values })","fork({ values })"),j=L(W.cloneOf)):Y0(D)?(i(0,"hydrate(domain, { values })","fork({ values })"),j=L(D)):M(0,"first argument of hydrate should be domain or scope"),x1(j,(A,_)=>{if(_&&D0(K,_)){G(O,A);let N=S(A,"serialize");N&&N!=="ignore"&&(I[_]=N.read(I[_])),G(C,I[_])}else A.scope.state.id in E&&(G(O,A),G(C,Z.get(E[A.scope.state.id])))},1),r({target:O,params:C,scope:W}),Q&&Object.assign(W.values.sidMap,I)}function J2(D,{scope:F,safe:I}={}){M(F||x||I,"scopeBind: scope not found");let Z=F||x;return(...K)=>{function E(){k0(W)}let O,C=0,W=x;k0(Z);try{O=D(...K)}catch(j){O=j,C=1}if(E(),C)throw O;return O instanceof Promise&&O.then(E,E),O}}function U2(D,F={}){D.warnSerializeNodes.size&&(console.error("serialize: One or more stores dont have sids, their values are omitted"),v(D.warnSerializeNodes,(K)=>{G1("store should have sid or `serialize: ignore`",K)})),M(!D.hasSidDoubles,"duplicate sid found in this scope");let I=F.ignore?F.ignore.map(({sid:K})=>K):[],Z={};return o(D.values.sidMap,(K,E)=>{var O;if(D0(I,E))return;let C=D.sidIdMap[E],W=(O=D.sidSerializeSettings.get(E))!==null&&O!==void 0?O:{ignore:0,write:Z2};W.ignore||(Z[E]=(0,W.write)(C&&C in D.reg?D.reg[C].current:K))}),"onlyChanges"in F&&(i(0,"onlyChanges"),F.onlyChanges||(M(D.cloneOf,"scope should be created from domain"),x1(L(D.cloneOf),(K,E)=>{E in Z||D0(I,E)||S(K,"isCombine")||S(K,"serialize")==="ignore"||(Z[E]=D.getState(K))}))),Z}function q2({unit:D,fn:F,scope:I,batch:Z}){let K=[G0.run({fn:(O)=>F(O)})];Z&&K.unshift(G0.compute({priority:"sampler",batch:1})),k(D)&&K.unshift(G0.mov({store:D.stateRef,to:"stack"}));let E=Array.isArray(D)?D:[D];if(I){let O=[],C=I.additionalLinks;return E.forEach((W)=>{let j=C[W.graphite.id]||[];C[W.graphite.id]=j;let Q=P({node:s1(K,W),meta:{watchOp:W.kind}});j.push(Q),O.push(()=>{let A=j.indexOf(Q);A!==-1&&j.splice(A,1),w0(Q)})}),d0(()=>{O.forEach((W)=>W())})}{let O=P({node:K,parent:E,family:{owners:E}});return d0(()=>{w0(O)})}}function s1(D,F){return k(F)?[G0.mov({store:F.stateRef,to:"stack"}),...D]:D}var s0=typeof Symbol<"u"&&Symbol.observable||"@@observable",W0="map",L=(D)=>D.graphite||D,V0=(D)=>D.family.owners,H0=(D)=>D.family.links,p=(D)=>D.stateRef,J0=(D)=>D.value,b=(D)=>D.parent,I0=(D)=>D.scope,S=(D,F)=>L(D).meta[F],m=(D,F,I)=>L(D).meta[F]=I,h0=(D)=>D.compositeName,u=(D)=>(h(D)||d(D))&&("kind"in D),z0=(D)=>(F)=>u(F)&&F.kind===D,k=z0("store"),F1=z0("event"),F0=z0("effect"),I1=(D)=>u(D)&&!!D.targetable,Y0=z0("domain"),U0=z0("scope"),V2={__proto__:null,unit:u,store:k,event:F1,effect:F0,targetable:I1,domain:Y0,scope:U0,attached:(D)=>F0(D)&&S(D,"attached")==1},D0=(D,F)=>D.includes(F),l0=(D,F)=>{let I=D.indexOf(F);I!==-1&&D.splice(I,1)},G=(D,F)=>D.push(F),i=(D,F,I,Z)=>!D&&console.error(`${Z?Z+": ":""}${F} is deprecated${I?`, use ${I} instead`:""}`),G1=(D,F)=>{let I=S(F,"unitTrace"),Z=S(F,"config"),K=Z!=null&&Z.loc?` at ${Z.loc.file}`:null,E=Z==null?void 0:Z.name,O=D;E&&(O=`${E}: ${D}`),K&&(O=`${E}${K}: ${D}`);let C=Error(O);I&&(C.stack=I),I||E||K||console.log(`Add effector's Babel or SWC plugin to your config for more detailed debug information or "import "effector/enable_debug_traces" to your code entry module to see full stack traces`),console.error(C)},T0=()=>{let D=0;return()=>""+ ++D},i1=T0(),v1=T0(),o1=T0(),a1=T0(),i0,H2=(D)=>{i0=D},y=null,K1=(D)=>{i0&&i0(D,y)},X0=()=>y&&y.template,L1=(D)=>(D&&y&&y.sidRoot&&(D=`${y.sidRoot}|${D}`),D),z2=({sid:D,name:F,loc:I,method:Z,fn:K})=>u1(P({meta:{sidRoot:L1(D),sid:D,name:F,loc:I,method:Z,type:"factory"},regional:1}),K),t=(D,F)=>{let I=L(D);v(F,(Z)=>{let K=L(Z);I.family.type!=="domain"&&(K.family.type="crosslink"),G(V0(K),I),G(H0(I),K)})},N0=(D=[])=>(Array.isArray(D)?D:[D]).flat().map(L),d=(D)=>typeof D=="object"&&D!==null,h=(D)=>typeof D=="function",l=(D)=>D===void 0,Z1=(D)=>M(d(D)||h(D),"expect first argument be an object"),N1=(D,F,I,Z)=>M(!(!d(D)&&!h(D)||!("family"in D)&&!("graphite"in D)),`${F}: expect ${I} to be a unit (store, event or effect)${Z}`),B0=(D,F,I)=>{Array.isArray(D)?v(D,(Z,K)=>N1(Z,F,`${K} item of ${I}`,"")):N1(D,F,I," or array of units")},E1=(D,F,I="target")=>v(N0(F),(Z)=>M(!S(Z,"derived"),`${D}: derived unit in "${I}" is not supported, use createStore/createEvent instead"`)),S1=(D,{fn:F},{a:I})=>F(D,I),n1=(D,{fn:F},{a:I})=>F(I,D),m0=(D,{fn:F})=>F(D),P1=(D,F,I,Z)=>{let K={id:v1(),type:D,data:F};return I&&(K.order={priority:I},Z&&(K.order.barrierID=++r1)),K},r1=0,c=({from:D="store",store:F,target:I,to:Z=I?"store":"stack",batch:K,priority:E})=>P1("mov",{from:D,store:F,to:Z,target:I},E,K),j0=({fn:D,batch:F,priority:I,safe:Z=0,filter:K=0,pure:E=0})=>P1("compute",{fn:D,safe:Z,filter:K,pure:E},I,F),O1=({fn:D})=>j0({fn:D,priority:"effect"}),$=(D,F,I)=>j0({fn:D,safe:1,filter:F,priority:I&&"effect"}),a=(D,F,I)=>c({store:D,to:F?"stack":"a",priority:I&&"sampler",batch:1}),n=(D=m0,F)=>j0({fn:D,pure:1,filter:F}),G0={mov:c,compute:j0,filter:({fn:D,pure:F})=>j0({fn:D,filter:1,pure:F}),run:O1},A0=(D)=>({id:v1(),current:D,initial:D}),q0=({current:D})=>D,$0=(D,F)=>{D.before||(D.before=[]),G(D.before,F)},_0=null,C1=(D,F)=>{if(!D)return F;if(!F)return D;let I;return(D.v.type===F.v.type&&D.v.id>F.v.id||a0(D.v.type)>a0(F.v.type))&&(I=D,D=F,F=I),I=C1(D.r,F),D.r=D.l,D.l=I,D},j1=[],J1=0;for(;J1<6;)G(j1,{first:null,last:null,size:0}),J1+=1;var t1=()=>{for(let D=0;D<6;D++){let F=j1[D];if(F.size>0){if(D===3||D===4){F.size-=1;let Z=_0.v;return _0=C1(_0.l,_0.r),Z}F.size===1&&(F.last=null);let I=F.first;return F.first=I.r,F.size-=1,I.v}}},C0=(D,F,I,Z,K,E,O)=>o0(0,{a:null,b:null,node:I,parent:Z,value:K,page:F,scope:E,meta:O},D,0),o0=(D,F,I,Z)=>{let K=a0(I),E=j1[K],O={v:{idx:D,stack:F,type:I,id:Z},l:null,r:null};K===3||K===4?_0=C1(_0,O):(E.size===0?E.first=O:E.last.r=O,E.last=O),E.size+=1},a0=(D)=>{switch(D){case"child":return 0;case"pure":return 1;case"read":return 2;case"barrier":return 3;case"sampler":return 4;case"effect":return 5;default:return-1}},f0=new Set,x,g0=1,v0=0,L0=0,s=null,k0=(D)=>{x=D},U1=(D)=>{s=D},$1=(D,F)=>{if(D){for(;D&&!D.reg[F];)D=D.parent;if(D)return D}return null},n0=(D,F,I,Z)=>{let K=$1(D,I.id);return K?K.reg[I.id]:F?(R0(F,I,Z),F.reg[I.id]):I},r0,Y2=(D)=>{r0=D},e1=(D)=>D,R0=(D,F,I,Z,K)=>{let E=D.reg;if(E[F.id])return;let O=F.sid,C={id:F.id,current:F.initial,meta:F.meta};if(C.id in D.values.idMap)C.current=D.values.idMap[C.id];else if(O&&O in D.values.sidMap&&!(O in D.sidIdMap)){var W;let j=F==null||(W=F.meta)===null||W===void 0?void 0:W.serialize;C.current=(D.fromSerialize&&j!=="ignore"&&(j==null?void 0:j.read)||e1)(D.values.sidMap[O])}else if(F.before&&!K){let j=0,Q=I||!F.noInit||Z;v(F.before,(A)=>{switch(A.type){case"map":{let _=A.from;if((_||A.fn)&&(_&&R0(D,_,I,Z),Q)){let N=_&&E[_.id].current;C.current=A.fn?A.fn(N):N}break}case"field":R0(D,A.from,I,Z),j||(j=1,C.current=Array.isArray(C.current)?[...C.current]:{...C.current}),Q&&(C.current[A.field]=E[E[A.from.id].id].current)}})}O&&(D.sidIdMap[O]=F.id),E[F.id]=C},D2=(D,F,I)=>{try{return F(J0(I),D.scope,I)}catch(Z){console.error(Z),D.fail=1,D.failReason=Z}},Z0=(D,F={})=>(d(D)&&(Z0(D.or,F),o(D,(I,Z)=>{l(I)||Z==="or"||Z==="and"||(F[Z]=I)}),Z0(D.and,F)),F),q1=(D,F)=>{l0(D.next,F),l0(V0(D),F),l0(H0(D),F)},V1=["on","reset","sample","split","merge","guard","forward"],S0=(D,F,I,Z,K)=>{let E;D.next.length=0,D.seq.length=0,D.scope=null;let O=H0(D),{stateRef:C,defaultShape:W,isRegion:j,op:Q}=D.meta;if(C&&(C.before=[],D.meta.stateRef=null),W)for(let _ in W)W[_]=null;let A=j?D:Z;if(O.length>0){let _=D0(V1,Q),N=!j&&!K,B=N&&I&&!_;for(;E=O.pop();){let R=D0(E.next,D);q1(E,D),j&&S0(E,0,0,D,1),R||(E.family.triggers-=1),(F||B||N&&E.family.type==="crosslink"&&!_||K&&D0(V1,E.meta.op)&&(R&&E.next.length===0||!R&&E.family.triggers<=0))&&S0(E,F,I&&E.meta.op!=="on",A,K)}}for(O=V0(D);E=O.pop();)q1(E,D),I&&E.family.type==="crosslink"&&S0(E,F,E.meta.op!=="on",A,K)},x0=(D)=>D.clear(),w0=(D,{deep:F}={})=>{let I=0;if(D.ownerSet&&D.ownerSet.delete(D),Y0(D)){I=1;let Z=D.history;x0(Z.events),x0(Z.effects),x0(Z.stores),x0(Z.domains)}S0(L(D),!!F,I,null,0)},A1=(D)=>d0(()=>w0(D)),e=(D,F,I,Z,K)=>P({node:I,parent:D,child:F,scope:{fn:K},meta:{op:Z},family:{owners:[D,F],links:F},regional:1}),M2=(D)=>{let[{from:I,to:Z},K]=E0(D,1),E=T("forward",K);return i(0,"forward","sample",E),B0(I,E,'"from"'),B0(Z,E,'"to"'),E1(E,Z,"to"),A1(P({parent:I,child:Z,meta:{op:"forward",config:K},family:{},regional:1}))},k1=(D,F)=>(M(h(F),".watch argument should be a function"),A1(P({scope:{fn:F},node:[O1({fn:m0})],parent:D,meta:{op:"watch"},family:{owners:D},regional:1}))),w1=0,_1=(D,F,I="event")=>{b(D)&&b(D).hooks[I](F)},M0=(D,F)=>m(D,"unitTrace",F),O0=(D)=>{if(!w1)return"";let F=Error("unit trace");return Error.captureStackTrace&&Error.captureStackTrace(F,D),F.stack},W1=(D,F,I,Z)=>{let K=Z0(I),E=D==="domain",O=i1(),{sid:C=null,named:W=null,domain:j=null,parent:Q=j}=K,A=W||K.name||(E?"":O),_=t0(A,Q),N={op:F.kind=D,name:F.shortName=A,sid:F.sid=L1(C),named:W,unitId:F.id=O,serialize:K.serialize,derived:K.derived,config:K,unitTrace:Z};if(F.targetable=!K.derived,F.parent=Q,F.compositeName=_,F.defaultConfig=K,F.getType=()=>(i(0,"getType","compositeName.fullName"),_.fullName),!E){F.subscribe=(R)=>(Z1(R),F.watch(h(R)?R:(V)=>R.next&&R.next(V))),F[s0]=()=>F;let B=X0();B&&(N.nativeTemplate=B)}return N},p0=(D,F,I,Z)=>{let K;d(I)&&(K=I,I=I.fn);let E=w({name:`${D.shortName} → *`,derived:1,and:K});return e(D,E,Z,F,I),E},P0="undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option",y1=(D,F,I,Z,K)=>{let E=p(F),O=c({store:E,to:"a",priority:"read"});I===W0&&(O.data.softRead=1);let C=[O,n(Z)];f("storeOnMap",E,C,k(D)&&p(D));let W=e(D,F,C,I,K);return I!==W0&&m(W,"onTrigger",L(D).id),W},F2=(D,F,I,Z,K,E,O)=>{let C=T("combine",K),W=D?(J)=>[...J]:(J)=>({...J}),j=D?[]:{},Q=W(j),A=A0(Q),_=A0(1);A.type=D?"list":"shape",A.noInit=1,f("combineBase",A,_);let N=K0(Q,{name:Y1(I),derived:1,...O,and:K});M0(N,Z);let B=p(N);B.noInit=1,m(N,"isCombine",1),t(N,[P({meta:{stateRef:A}})]);let R=a(A);R.order={priority:"barrier"};let V=c({store:B,to:"b",priority:"read"});V.data.softRead=1;let X=[$((J,U,q)=>(q.scope&&!q.scope.reg[A.id]&&(q.c=1),J)),R,c({store:_,to:"b"}),$((J,{key:U},q)=>{if(q.c||J!==q.a[U])return F&&q.b&&(q.a=W(q.a)),q.a[U]=J,1},1),c({from:"a",target:A}),c({from:"value",store:0,target:_}),c({from:"value",store:1,target:_,priority:"barrier",batch:1}),a(A,1,1),E&&n(),V];if(o(I,(J,U)=>{if(!k(J))return M(!u(J)&&!l(J),`combine expects a store in a field ${U}`,C),void(Q[U]=j[U]=J);j[U]=J.defaultState,Q[U]=J.getState();let q=e(J,N,X,"combine",E);q.scope.key=U;let z=p(J);$0(A,{type:"field",field:U,from:z}),f("combineField",z,q)}),N.defaultShape=I,m(N,"defaultShape",I),$0(B,{type:W0,from:A,fn:E}),!X0())if(E){let J=E(Q);!l(J)||O&&"skipVoid"in O||console.error(`${C}: ${P0}`),B.current=J,B.initial=J,N.defaultState=J}else N.defaultState=j;return N},h1=(D,F,I)=>{try{return[1,D(...I)]}catch(Z){return F(Z),[0,null]}},y0=(D,F,I,Z,K)=>(E)=>{r({target:[Z,I2],params:[I?{status:"done",params:D,result:E}:{status:"fail",params:D,error:E},{value:E,fn:I?F.rs:F.rj}],defer:1,page:K.page,scope:K.scope,meta:K.meta})},I2=P({node:[O1({fn:({fn:D,value:F})=>D(F)})],meta:{op:"fx",fx:"sidechain"}}),K2=["source","clock","target"],T1=(D,F)=>D+`: ${F} should be defined`,B1=(D,F,I,Z,K,E,O,C,W,j,Q,A)=>{let _=T(D,C),N=!!K;M(!l(I)||!l(F),T1(_,"either source or clock"));let B=0;l(I)?B=1:u(I)||(I=e0(I)),l(F)?F=I:(B0(F,_,"clock"),Array.isArray(F)&&(F=e(F,[],[],D))),B&&(I=F),C||O?C&&O?C.name=O:!C&&O&&(C={name:O}):O=I.shortName;let R="none";(Q||Z)&&(u(Z)?R="unit":(M(h(Z),"`filter` should be function or unit"),R="fn")),K?(B0(K,_,"target"),E1(_,K)):R==="none"&&j&&k(I)&&k(F)?K=K0(E?E(q0(p(I)),q0(p(F))):q0(p(I)),{name:O,sid:A,or:C}):(K=w({name:O,derived:1,or:C}),f("sampleTarget",L(K)));let V=A0(),X=[],J=[];if(R==="unit"){let[z,Y,H,g]=H1(Z,K,F,V,D);g&&G(J,g),H||X.push(...u0(Y)),X.push(...u0(z))}let U=[];if(B)W&&G(U,a(V,1,1));else{let[z,Y,H,g]=H1(I,K,F,V,D);g&&G(J,g),H||U.push(...u0(Y)),G(U,a(z,1,W))}let q=e(F,K,[f("sampleSourceLoader"),c({from:"stack",target:V}),...U,...X,a(V),R==="fn"&&n((z,Y,{a:H})=>Z(z,H),1),E&&n(S1),f("sampleSourceUpward",N)],D,E);return t(I,[q]),t(q,J),Object.assign(q.meta,C,{joint:1,stateRef:V}),M0(q,O0(d1)),K},u0=(D)=>[a(D),$((F,I,{a:Z})=>Z,1)],H1=(D,F,I,Z,K)=>{let E=k(D),O=E?p(D):A0(),C=A0(E),W;return E||(W=P({parent:D,node:[c({from:"stack",target:O}),c({from:"value",store:1,target:C})],family:{owners:[...new Set([D,F,I].flat())],links:F},meta:{op:K},regional:1})),f("sampleSource",C,O,Z),[O,C,E,W]},b0=(D,F,I,Z)=>{let K=D[F];K&&r({target:K,params:Array.isArray(K)?K.map(()=>I):I,defer:1,stack:Z})},g2="23.4.4",z1=(D)=>!D.node.meta.isCombine||D.parent&&D.parent.node.meta.op!=="combine",Z2=(D)=>D,x2={setDebugTraces:(D)=>{w1=D,D&&console.log("[effector/debug_traces] Debug traces enabled")}};export{u1 as withRegion,z2 as withFactory,g2 as version,G0 as step,c1 as split,j2 as setStoreName,Y2 as setInspector,H2 as setGraphInspector,U2 as serialize,J2 as scopeBind,d1 as sample,R2 as restore,B2 as merge,r as launch,V2 as is,N2 as hydrate,W2 as guard,_2 as fromObservable,M2 as forward,Q2 as fork,q2 as createWatch,K0 as createStore,P as createNode,w as createEvent,D1 as createEffect,Q1 as createDomain,A2 as createApi,e0 as combine,w0 as clearNode,b1 as attach,X2 as allSettled,x2 as PRIVATE_API_DO_NOT_TOUCH_NO_SEMVER_SUPPORT};
