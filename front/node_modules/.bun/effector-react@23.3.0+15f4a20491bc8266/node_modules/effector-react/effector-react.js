var J0=Object.create;var{getPrototypeOf:j0,defineProperty:gR,getOwnPropertyNames:q0}=Object;var I0=Object.prototype.hasOwnProperty;var bO=(O,_,E)=>{E=O!=null?J0(j0(O)):{};let D=_||!O||!O.__esModule?gR(E,"default",{value:O,enumerable:!0}):E;for(let L of q0(O))if(!I0.call(D,L))gR(D,L,{get:()=>O[L],enumerable:!0});return D};var N_=(O,_)=>()=>(_||O((_={exports:{}}).exports,_),_.exports);var J_=N_((y0,$_)=>{(function(){function O(R,G){Object.defineProperty(D.prototype,R,{get:function(){console.warn("%s(...) is deprecated in plain JavaScript React classes. %s",G[0],G[1])}})}function _(R){if(R===null||typeof R!=="object")return null;return R=$R&&R[$R]||R["@@iterator"],typeof R==="function"?R:null}function E(R,G){R=(R=R.constructor)&&(R.displayName||R.name)||"ReactClass";var $=R+"."+G;JR[$]||(console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",G,R),JR[$]=!0)}function D(R,G,$){this.props=R,this.context=G,this.refs=P_,this.updater=$||jR}function L(){}function B(R,G,$){this.props=R,this.context=G,this.refs=P_,this.updater=$||jR}function Z(){}function H(R){return""+R}function X(R){try{H(R);var G=!1}catch(T){G=!0}if(G){G=console;var $=G.error,w=typeof Symbol==="function"&&Symbol.toStringTag&&R[Symbol.toStringTag]||R.constructor.name||"Object";return $.call(G,"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",w),H(R)}}function W(R){if(R==null)return null;if(typeof R==="function")return R.$$typeof===Y0?null:R.displayName||R.name||null;if(typeof R==="string")return R;switch(R){case C_:return"Fragment";case KR:return"Profiler";case UR:return"StrictMode";case AR:return"Suspense";case K0:return"SuspenseList";case zR:return"Activity"}if(typeof R==="object")switch(typeof R.tag==="number"&&console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),R.$$typeof){case XR:return"Portal";case YR:return R.displayName||"Context";case F_:return(R._context.displayName||"Context")+".Consumer";case QR:var G=R.render;return R=R.displayName,R||(R=G.displayName||G.name||"",R=R!==""?"ForwardRef("+R+")":"ForwardRef"),R;case T_:return G=R.displayName||null,G!==null?G:W(R.type)||"Memo";case mO:G=R._payload,R=R._init;try{return W(R(G))}catch($){}}return null}function A(R){if(R===C_)return"<>";if(typeof R==="object"&&R!==null&&R.$$typeof===mO)return"<...>";try{var G=W(R);return G?"<"+G+">":"<...>"}catch($){return"<...>"}}function K(){var R=v.A;return R===null?null:R.getOwner()}function U(){return Error("react-stack-top-frame")}function Q(R){if(eO.call(R,"key")){var G=Object.getOwnPropertyDescriptor(R,"key").get;if(G&&G.isReactWarning)return!1}return R.key!==void 0}function M(R,G){function $(){CR||(CR=!0,console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",G))}$.isReactWarning=!0,Object.defineProperty(R,"key",{get:$,configurable:!0})}function Y(){var R=W(this.type);return TR[R]||(TR[R]=!0,console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")),R=this.props.ref,R!==void 0?R:null}function q(R,G,$,w,T,x){var N=$.ref;return R={$$typeof:w_,type:R,key:G,props:$,_owner:w},(N!==void 0?N:null)!==null?Object.defineProperty(R,"ref",{enumerable:!1,get:Y}):Object.defineProperty(R,"ref",{enumerable:!1,value:null}),R._store={},Object.defineProperty(R._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:0}),Object.defineProperty(R,"_debugInfo",{configurable:!1,enumerable:!1,writable:!0,value:null}),Object.defineProperty(R,"_debugStack",{configurable:!1,enumerable:!1,writable:!0,value:T}),Object.defineProperty(R,"_debugTask",{configurable:!1,enumerable:!1,writable:!0,value:x}),Object.freeze&&(Object.freeze(R.props),Object.freeze(R)),R}function z(R,G){return G=q(R.type,G,R.props,R._owner,R._debugStack,R._debugTask),R._store&&(G._store.validated=R._store.validated),G}function J(R){j(R)?R._store&&(R._store.validated=1):typeof R==="object"&&R!==null&&R.$$typeof===mO&&(R._payload.status==="fulfilled"?j(R._payload.value)&&R._payload.value._store&&(R._payload.value._store.validated=1):R._store&&(R._store.validated=1))}function j(R){return typeof R==="object"&&R!==null&&R.$$typeof===w_}function I(R){var G={"=":"=0",":":"=2"};return"$"+R.replace(/[=:]/g,function($){return G[$]})}function F(R,G){return typeof R==="object"&&R!==null&&R.key!=null?(X(R.key),I(""+R.key)):G.toString(36)}function P(R){switch(R.status){case"fulfilled":return R.value;case"rejected":throw R.reason;default:switch(typeof R.status==="string"?R.then(Z,Z):(R.status="pending",R.then(function(G){R.status==="pending"&&(R.status="fulfilled",R.value=G)},function(G){R.status==="pending"&&(R.status="rejected",R.reason=G)})),R.status){case"fulfilled":return R.value;case"rejected":throw R.reason}}throw R}function C(R,G,$,w,T){var x=typeof R;if(x==="undefined"||x==="boolean")R=null;var N=!1;if(R===null)N=!0;else switch(x){case"bigint":case"string":case"number":N=!0;break;case"object":switch(R.$$typeof){case w_:case XR:N=!0;break;case mO:return N=R._init,C(N(R._payload),G,$,w,T)}}if(N){N=R,T=T(N);var k=w===""?"."+F(N,0):w;return IR(T)?($="",k!=null&&($=k.replace(VR,"$&/")+"/"),C(T,G,$,"",function(jO){return jO})):T!=null&&(j(T)&&(T.key!=null&&(N&&N.key===T.key||X(T.key)),$=z(T,$+(T.key==null||N&&N.key===T.key?"":(""+T.key).replace(VR,"$&/")+"/")+k),w!==""&&N!=null&&j(N)&&N.key==null&&N._store&&!N._store.validated&&($._store.validated=2),T=$),G.push(T)),1}if(N=0,k=w===""?".":w+":",IR(R))for(var g=0;g<R.length;g++)w=R[g],x=k+F(w,g),N+=C(w,G,$,x,T);else if(g=_(R),typeof g==="function")for(g===R.entries&&(PR||console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),PR=!0),R=g.call(R),g=0;!(w=R.next()).done;)w=w.value,x=k+F(w,g++),N+=C(w,G,$,x,T);else if(x==="object"){if(typeof R.then==="function")return C(P(R),G,$,w,T);throw G=String(R),Error("Objects are not valid as a React child (found: "+(G==="[object Object]"?"object with keys {"+Object.keys(R).join(", ")+"}":G)+"). If you meant to render a collection of children, use an array instead.")}return N}function V(R,G,$){if(R==null)return R;var w=[],T=0;return C(R,w,"","",function(x){return G.call($,x,T++)}),w}function l(R){if(R._status===-1){var G=R._ioInfo;G!=null&&(G.start=G.end=performance.now()),G=R._result;var $=G();if($.then(function(T){if(R._status===0||R._status===-1){R._status=1,R._result=T;var x=R._ioInfo;x!=null&&(x.end=performance.now()),$.status===void 0&&($.status="fulfilled",$.value=T)}},function(T){if(R._status===0||R._status===-1){R._status=2,R._result=T;var x=R._ioInfo;x!=null&&(x.end=performance.now()),$.status===void 0&&($.status="rejected",$.reason=T)}}),G=R._ioInfo,G!=null){G.value=$;var w=$.displayName;typeof w==="string"&&(G.name=w)}R._status===-1&&(R._status=0,R._result=$)}if(R._status===1)return G=R._result,G===void 0&&console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,G),"default"in G||console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,G),G.default;throw R._result}function y(){var R=v.H;return R===null&&console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`),R}function MR(){v.asyncTransitions--}function rO(R){if(O_===null)try{var G=("require"+Math.random()).slice(0,7);O_=($_&&$_[G]).call($_,"timers").setImmediate}catch($){O_=function(w){vR===!1&&(vR=!0,typeof MessageChannel>"u"&&console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));var T=new MessageChannel;T.port1.onmessage=w,T.port2.postMessage(void 0)}}return O_(R)}function uO(R){return 1<R.length&&typeof AggregateError==="function"?AggregateError(R):R[0]}function tO(R,G){G!==__-1&&console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "),__=G}function q_(R,G,$){var w=v.actQueue;if(w!==null)if(w.length!==0)try{I_(w),rO(function(){return q_(R,G,$)});return}catch(T){v.thrownErrors.push(T)}else v.actQueue=null;0<v.thrownErrors.length?(w=uO(v.thrownErrors),v.thrownErrors.length=0,$(w)):G(R)}function I_(R){if(!V_){V_=!0;var G=0;try{for(;G<R.length;G++){var $=R[G];do{v.didUsePromise=!1;var w=$(!1);if(w!==null){if(v.didUsePromise){R[G]=$,R.splice(0,G);return}$=w}else break}while(1)}R.length=0}catch(T){R.splice(0,G+1),v.thrownErrors.push(T)}finally{V_=!1}}}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var w_=Symbol.for("react.transitional.element"),XR=Symbol.for("react.portal"),C_=Symbol.for("react.fragment"),UR=Symbol.for("react.strict_mode"),KR=Symbol.for("react.profiler"),F_=Symbol.for("react.consumer"),YR=Symbol.for("react.context"),QR=Symbol.for("react.forward_ref"),AR=Symbol.for("react.suspense"),K0=Symbol.for("react.suspense_list"),T_=Symbol.for("react.memo"),mO=Symbol.for("react.lazy"),zR=Symbol.for("react.activity"),$R=Symbol.iterator,JR={},jR={isMounted:function(){return!1},enqueueForceUpdate:function(R){E(R,"forceUpdate")},enqueueReplaceState:function(R){E(R,"replaceState")},enqueueSetState:function(R){E(R,"setState")}},qR=Object.assign,P_={};Object.freeze(P_),D.prototype.isReactComponent={},D.prototype.setState=function(R,G){if(typeof R!=="object"&&typeof R!=="function"&&R!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,R,G,"setState")},D.prototype.forceUpdate=function(R){this.updater.enqueueForceUpdate(this,R,"forceUpdate")};var DO={isMounted:["isMounted","Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],replaceState:["replaceState","Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]};for(hO in DO)DO.hasOwnProperty(hO)&&O(hO,DO[hO]);L.prototype=D.prototype,DO=B.prototype=new L,DO.constructor=B,qR(DO,D.prototype),DO.isPureReactComponent=!0;var IR=Array.isArray,Y0=Symbol.for("react.client.reference"),v={H:null,A:null,T:null,S:null,actQueue:null,asyncTransitions:0,isBatchingLegacy:!1,didScheduleLegacyUpdate:!1,didUsePromise:!1,thrownErrors:[],getCurrentStack:null,recentlyCreatedOwnerStacks:0},eO=Object.prototype.hasOwnProperty,wR=console.createTask?console.createTask:function(){return null};DO={react_stack_bottom_frame:function(R){return R()}};var CR,FR,TR={},Q0=DO.react_stack_bottom_frame.bind(DO,U)(),A0=wR(A(U)),PR=!1,VR=/\/+/g,NR=typeof reportError==="function"?reportError:function(R){if(typeof window==="object"&&typeof window.ErrorEvent==="function"){var G=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof R==="object"&&R!==null&&typeof R.message==="string"?String(R.message):String(R),error:R});if(!window.dispatchEvent(G))return}else if(typeof process==="object"&&typeof process.emit==="function"){process.emit("uncaughtException",R);return}console.error(R)},vR=!1,O_=null,__=0,R_=!1,V_=!1,xR=typeof queueMicrotask==="function"?function(R){queueMicrotask(function(){return queueMicrotask(R)})}:rO;DO=Object.freeze({__proto__:null,c:function(R){return y().useMemoCache(R)}});var hO={map:V,forEach:function(R,G,$){V(R,function(){G.apply(this,arguments)},$)},count:function(R){var G=0;return V(R,function(){G++}),G},toArray:function(R){return V(R,function(G){return G})||[]},only:function(R){if(!j(R))throw Error("React.Children.only expected to receive a single React element child.");return R}};y0.Activity=zR,y0.Children=hO,y0.Component=D,y0.Fragment=C_,y0.Profiler=KR,y0.PureComponent=B,y0.StrictMode=UR,y0.Suspense=AR,y0.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=v,y0.__COMPILER_RUNTIME=DO,y0.act=function(R){var G=v.actQueue,$=__;__++;var w=v.actQueue=G!==null?G:[],T=!1;try{var x=R()}catch(g){v.thrownErrors.push(g)}if(0<v.thrownErrors.length)throw tO(G,$),R=uO(v.thrownErrors),v.thrownErrors.length=0,R;if(x!==null&&typeof x==="object"&&typeof x.then==="function"){var N=x;return xR(function(){T||R_||(R_=!0,console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"))}),{then:function(g,jO){T=!0,N.then(function(NO){if(tO(G,$),$===0){try{I_(w),rO(function(){return q_(NO,g,jO)})}catch($0){v.thrownErrors.push($0)}if(0<v.thrownErrors.length){var z0=uO(v.thrownErrors);v.thrownErrors.length=0,jO(z0)}}else g(NO)},function(NO){tO(G,$),0<v.thrownErrors.length?(NO=uO(v.thrownErrors),v.thrownErrors.length=0,jO(NO)):jO(NO)})}}}var k=x;if(tO(G,$),$===0&&(I_(w),w.length!==0&&xR(function(){T||R_||(R_=!0,console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"))}),v.actQueue=null),0<v.thrownErrors.length)throw R=uO(v.thrownErrors),v.thrownErrors.length=0,R;return{then:function(g,jO){T=!0,$===0?(v.actQueue=w,rO(function(){return q_(k,g,jO)})):g(k)}}},y0.cache=function(R){return function(){return R.apply(null,arguments)}},y0.cacheSignal=function(){return null},y0.captureOwnerStack=function(){var R=v.getCurrentStack;return R===null?null:R()},y0.cloneElement=function(R,G,$){if(R===null||R===void 0)throw Error("The argument must be a React element, but you passed "+R+".");var w=qR({},R.props),T=R.key,x=R._owner;if(G!=null){var N;O:{if(eO.call(G,"ref")&&(N=Object.getOwnPropertyDescriptor(G,"ref").get)&&N.isReactWarning){N=!1;break O}N=G.ref!==void 0}N&&(x=K()),Q(G)&&(X(G.key),T=""+G.key);for(k in G)!eO.call(G,k)||k==="key"||k==="__self"||k==="__source"||k==="ref"&&G.ref===void 0||(w[k]=G[k])}var k=arguments.length-2;if(k===1)w.children=$;else if(1<k){N=Array(k);for(var g=0;g<k;g++)N[g]=arguments[g+2];w.children=N}w=q(R.type,T,w,x,R._debugStack,R._debugTask);for(T=2;T<arguments.length;T++)J(arguments[T]);return w},y0.createContext=function(R){return R={$$typeof:YR,_currentValue:R,_currentValue2:R,_threadCount:0,Provider:null,Consumer:null},R.Provider=R,R.Consumer={$$typeof:F_,_context:R},R._currentRenderer=null,R._currentRenderer2=null,R},y0.createElement=function(R,G,$){for(var w=2;w<arguments.length;w++)J(arguments[w]);w={};var T=null;if(G!=null)for(g in FR||!("__self"in G)||"key"in G||(FR=!0,console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")),Q(G)&&(X(G.key),T=""+G.key),G)eO.call(G,g)&&g!=="key"&&g!=="__self"&&g!=="__source"&&(w[g]=G[g]);var x=arguments.length-2;if(x===1)w.children=$;else if(1<x){for(var N=Array(x),k=0;k<x;k++)N[k]=arguments[k+2];Object.freeze&&Object.freeze(N),w.children=N}if(R&&R.defaultProps)for(g in x=R.defaultProps,x)w[g]===void 0&&(w[g]=x[g]);T&&M(w,typeof R==="function"?R.displayName||R.name||"Unknown":R);var g=1e4>v.recentlyCreatedOwnerStacks++;return q(R,T,w,K(),g?Error("react-stack-top-frame"):Q0,g?wR(A(R)):A0)},y0.createRef=function(){var R={current:null};return Object.seal(R),R},y0.forwardRef=function(R){R!=null&&R.$$typeof===T_?console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."):typeof R!=="function"?console.error("forwardRef requires a render function but was given %s.",R===null?"null":typeof R):R.length!==0&&R.length!==2&&console.error("forwardRef render functions accept exactly two parameters: props and ref. %s",R.length===1?"Did you forget to use the ref parameter?":"Any additional parameter will be undefined."),R!=null&&R.defaultProps!=null&&console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");var G={$$typeof:QR,render:R},$;return Object.defineProperty(G,"displayName",{enumerable:!1,configurable:!0,get:function(){return $},set:function(w){$=w,R.name||R.displayName||(Object.defineProperty(R,"name",{value:w}),R.displayName=w)}}),G},y0.isValidElement=j,y0.lazy=function(R){R={_status:-1,_result:R};var G={$$typeof:mO,_payload:R,_init:l},$={name:"lazy",start:-1,end:-1,value:null,owner:null,debugStack:Error("react-stack-top-frame"),debugTask:console.createTask?console.createTask("lazy()"):null};return R._ioInfo=$,G._debugInfo=[{awaited:$}],G},y0.memo=function(R,G){R==null&&console.error("memo: The first argument must be a component. Instead received: %s",R===null?"null":typeof R),G={$$typeof:T_,type:R,compare:G===void 0?null:G};var $;return Object.defineProperty(G,"displayName",{enumerable:!1,configurable:!0,get:function(){return $},set:function(w){$=w,R.name||R.displayName||(Object.defineProperty(R,"name",{value:w}),R.displayName=w)}}),G},y0.startTransition=function(R){var G=v.T,$={};$._updatedFibers=new Set,v.T=$;try{var w=R(),T=v.S;T!==null&&T($,w),typeof w==="object"&&w!==null&&typeof w.then==="function"&&(v.asyncTransitions++,w.then(MR,MR),w.then(Z,NR))}catch(x){NR(x)}finally{G===null&&$._updatedFibers&&(R=$._updatedFibers.size,$._updatedFibers.clear(),10<R&&console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")),G!==null&&$.types!==null&&(G.types!==null&&G.types!==$.types&&console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."),G.types=$.types),v.T=G}},y0.unstable_useCacheRefresh=function(){return y().useCacheRefresh()},y0.use=function(R){return y().use(R)},y0.useActionState=function(R,G,$){return y().useActionState(R,G,$)},y0.useCallback=function(R,G){return y().useCallback(R,G)},y0.useContext=function(R){var G=y();return R.$$typeof===F_&&console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"),G.useContext(R)},y0.useDebugValue=function(R,G){return y().useDebugValue(R,G)},y0.useDeferredValue=function(R,G){return y().useDeferredValue(R,G)},y0.useEffect=function(R,G){return R==null&&console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"),y().useEffect(R,G)},y0.useEffectEvent=function(R){return y().useEffectEvent(R)},y0.useId=function(){return y().useId()},y0.useImperativeHandle=function(R,G,$){return y().useImperativeHandle(R,G,$)},y0.useInsertionEffect=function(R,G){return R==null&&console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"),y().useInsertionEffect(R,G)},y0.useLayoutEffect=function(R,G){return R==null&&console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"),y().useLayoutEffect(R,G)},y0.useMemo=function(R,G){return y().useMemo(R,G)},y0.useOptimistic=function(R,G){return y().useOptimistic(R,G)},y0.useReducer=function(R,G,$){return y().useReducer(R,G,$)},y0.useRef=function(R){return y().useRef(R)},y0.useState=function(R){return y().useState(R)},y0.useSyncExternalStore=function(R,G,$){return y().useSyncExternalStore(R,G,$)},y0.useTransition=function(){return y().useTransition()},y0.version="19.2.4",typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var LR=N_((d0)=>{var LO=bO(J_());(function(){function O(U,Q){return U===Q&&(U!==0||1/U===1/Q)||U!==U&&Q!==Q}function _(U,Q){W||LO.startTransition===void 0||(W=!0,console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));var M=Q();if(!A){var Y=Q();L(M,Y)||(console.error("The result of getSnapshot should be cached to avoid an infinite loop"),A=!0)}Y=B({inst:{value:M,getSnapshot:Q}});var q=Y[0].inst,z=Y[1];return H(function(){q.value=M,q.getSnapshot=Q,E(q)&&z({inst:q})},[U,M,Q]),Z(function(){return E(q)&&z({inst:q}),U(function(){E(q)&&z({inst:q})})},[U]),X(M),M}function E(U){var Q=U.getSnapshot;U=U.value;try{var M=Q();return!L(U,M)}catch(Y){return!0}}function D(U,Q){return Q()}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var L=typeof Object.is==="function"?Object.is:O,B=LO.useState,Z=LO.useEffect,H=LO.useLayoutEffect,X=LO.useDebugValue,W=!1,A=!1,K=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?D:_;d0.useSyncExternalStore=LO.useSyncExternalStore!==void 0?LO.useSyncExternalStore:K,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var L0=N_((s0)=>{var JO=bO(J_());(function(){function O(X,W){return X===W&&(X!==0||1/X===1/W)||X!==X&&W!==W}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var _=LR(),E=typeof Object.is==="function"?Object.is:O,D=_.useSyncExternalStore,L=JO.useRef,B=JO.useEffect,Z=JO.useMemo,H=JO.useDebugValue;s0.useSyncExternalStoreWithSelector=function(X,W,A,K,U){var Q=L(null);if(Q.current===null){var M={hasValue:!1,value:null};Q.current=M}else M=Q.current;Q=Z(function(){function q(F){if(!z){if(z=!0,J=F,F=K(F),U!==void 0&&M.hasValue){var P=M.value;if(U(P,F))return j=P}return j=F}if(P=j,E(J,F))return P;var C=K(F);if(U!==void 0&&U(P,C))return J=F,P;return J=F,j=C}var z=!1,J,j,I=A===void 0?null:A;return[function(){return q(W())},I===null?void 0:function(){return q(I())}]},[W,A,K,U]);var Y=D(X,Q[0],Q[1]);return B(function(){M.hasValue=!0,M.value=Y},[Y]),H(Y),Y},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});function WO(O,_){for(let E in O)_(O[E],E)}function h(O,_){O.forEach(_)}function S(O,_,E){if(!O)throw Error(`${E?E+": ":""}${_}`)}function w0(O,_){let E=b(O),D=E.meta||{};nO(O)||(D.isRegion=1),o={id:E.id,parent:o,value:O,template:D.template||fO(),sidRoot:D.sidRoot||o&&o.sidRoot,meta:D};try{return _()}finally{o_("region"),o=RO(o)}}function p({node:O=[],from:_,source:E,parent:D=_||E,to:L,target:B,child:Z=L||B,scope:H={},meta:X={},family:W={type:"regular"},regional:A}={}){let K=yO(D),U=yO(W.links),Q=yO(W.owners),M=[];h(O,(q)=>q&&m(M,q));let Y={id:N0(),seq:M,next:yO(Z),meta:X,scope:H,family:{triggers:K.length,type:W.type||"crosslink",links:U,owners:Q}};return h(U,(q)=>m(iO(q),Y)),h(Q,(q)=>m(lO(q),Y)),h(K,(q)=>m(q.next,Y)),A&&o&&QO(dO(o),[Y]),Y}function HO(O,_,E){let D,L=ZO,B=null,Z=u;if(O.target&&(_=O.params,E=O.defer,D=O.meta,L=("page"in O)?O.page:L,O.stack&&(B=O.stack),Z=qO(O)||Z,O=O.target),Z&&u&&Z!==u&&(u=null),Array.isArray(O))for(let M=0;M<O.length;M++)TO("pure",L,b(O[M]),B,_[M],Z,D);else TO("pure",L,b(O),B,_,Z,D);if(E&&!E_)return;let H={isRoot:E_,currentPage:ZO,scope:u,isWatch:B_,isPure:Z_},X,W,A,K,U,Q;E_=0;O:for(;K=S0();){let{idx:M,stack:Y,type:q}=K;A=Y.node,ZO=U=Y.page,u=qO(Y),U?Q=U.reg:u&&(Q=u.reg);let z=!!U,J=!!u,j={fail:0,scope:A.scope};X=W=0;for(let I=M;I<A.seq.length&&!X;I++){let F=A.seq[I];if(F.order){let{priority:P,barrierID:C}=F.order,V=C?U?`${U.fullID}_${C}`:C:0;if(I!==M||q!==P){C?x_.has(V)||(x_.add(V),b_(I,Y,P,C)):b_(I,Y,P,0);continue O}C&&x_.delete(V)}switch(F.type){case"mov":{let C=F.data,V;switch(C.from){case"stack":V=dO(Y);break;case"a":case"b":V=Y[C.from];break;case"value":V=C.store;break;case"store":if(Q&&!Q[C.store.id])if(z){let l=tR(U,C.store.id);Y.page=U=l,l?Q=l.reg:J?(SO(u,C.store,0,1,C.softRead),Q=u.reg):Q=void 0}else J&&SO(u,C.store,0,1,C.softRead);V=pO(Q&&Q[C.store.id]||C.store)}switch(C.to){case"stack":Y.value=V;break;case"a":case"b":Y[C.to]=V;break;case"store":d_(U,u,C.target,0).current=V}break}case"compute":let P=F.data;if(P.fn){B_=A.meta.op==="watch",Z_=P.pure;let C=P.safe?(0,P.fn)(dO(Y),j.scope,Y):k0(j,P.fn,Y);P.filter?W=!C:Y.value=C,B_=H.isWatch,Z_=H.isPure}}X=j.fail||W}if(s_&&s_(Y,j),!X){let I=dO(Y),F=qO(Y);if(h(A.next,(P)=>{TO("child",U,P,Y,I,F)}),F){A.meta.needFxCounter&&TO("child",U,F.fxCount,Y,I,F),A.meta.storeChange&&TO("child",U,F.storeChange,Y,I,F),A.meta.warnSerialize&&TO("child",U,F.warnSerializeNode,Y,I,F);let P=F.additionalLinks[A.id];P&&h(P,(C)=>{TO("child",U,C,Y,I,F)})}}}E_=H.isRoot,ZO=H.currentPage,u=qO(H)}function sR(O,_="combine"){let E=_+"(",D="",L=0;return WO(O,(B)=>{L<25&&(B!=null&&(E+=D,E+=_O(B)?Q_(B).fullName:B.toString()),L+=1,D=", ")}),E+")"}function o0(O,_){O.shortName=_,Object.assign(Q_(O),p_(_,RO(O)))}function p_(O,_){let E,D,L=O;if(_){let B=Q_(_);O.length===0?(E=B.path,D=B.fullName):(E=B.path.concat([O]),D=B.fullName.length===0?O:B.fullName+"/"+O)}else E=O.length===0?[]:[O],D=O;return{shortName:L,fullName:D,path:E}}function a(O,_){if(!_)return O;if(!_.name&&!_.named&&!_.loc)return O;let E=`[${O}]`,D=_.named||_.name;D&&(E+=` unit '${D}'`);let L=_.loc;return!D&&L&&(E+=` (${L.file}:${L.line}:${L.column})`),E}function wO(O,_){let E=_?O:O[0];n_(E);let{or:D,and:L}=E;if(L){let B=_?L:L[0];if(EO(B)&&"and"in B){let Z=wO(L,_);O=Z[0],D={...D,...Z[1]}}else O=L}return[O,D]}function k_(O){let _=()=>O();return _.unsubscribe=()=>O(),_}function e(O,..._){let E=fO();if(E){let D=E.handlers[O];if(D)return D(E,..._)}}function d(O,_){let E=IO({or:_,and:typeof O=="string"?{name:O}:O}),D=a("event",E),L=(H,...X)=>(S(!s(L,"derived"),"call of derived event is not supported, use createEvent instead",D),S(!Z_,"unit call from pure function is not supported, use operators like sample instead",D),ZO?((W,A,K,U)=>{let Q=ZO,M=null;if(A)for(M=ZO;M&&M.template!==A;)M=RO(M);mR(M);let Y=W.create(K,U);return mR(Q),Y})(L,B,H,X):L.create(H,X)),B=fO(),Z=Object.assign(L,{graphite:p({meta:RR(E.actualOp||"event",L,E,CO(d)),regional:1}),create:(H)=>(HO({target:L,params:H,scope:u}),H),watch:(H)=>eR(L,H),map:(H)=>g_(L,xO,H,[YO()]),filter:(H)=>g_(L,"filter",H.fn?H:H.fn,[YO(z_,1)]),filterMap:(H)=>g_(L,"filterMap",H,[YO(),c((X)=>!t(X),1)]),prepend(H){S(L.targetable,".prepend of derived event is not supported, call source event instead",D);let X=d("* → "+L.shortName,{parent:RO(L)});return e("eventPrepend",b(X)),AO(X,L,[YO()],"prepend",H),_R(L,X),X}});return E!=null&&E.domain&&E.domain.hooks.event(Z),r(Z,"id",Z.graphite.id),o_(Z.graphite),Z}function SR(O,_,E,D,L){return gO(E,`${L} ${_}`,"first argument"),S(n(D),"second argument should be a function",L),GO(!s(O,"derived"),`${_} in derived store`,`${_} in store created via createStore`,L),h(Array.isArray(E)?E:[E],(B)=>{O.off(B),_0(B,O,"on",x0,D)}),O}function XO(O,_){let E=IO(_),D=VO(O),L=a("store",E),B=d({named:"updates",derived:1});e("storeBase",D);let Z=D.id,H="skipVoid"in E,X=H&&!E.skipVoid;GO(!(H&&E.skipVoid),"{skipVoid: true}","updateFilter",L);let W={updates:B,defaultState:O,stateRef:D,getState(){let z,J=D;if(ZO){let j=ZO;for(;j&&!j.reg[Z];)j=RO(j);j&&(z=j)}return!z&&u&&(SO(u,D,1),z=u),z&&(J=z.reg[Z]),pO(J)},setState:(z)=>HO({target:W,params:z,defer:1,scope:u}),reset:(...z)=>(S(W.targetable,".reset of derived store is not supported",L),h(z,(J)=>SR(W,".reset",J,()=>W.defaultState,L)),W),on:(z,J)=>(S(W.targetable,".on of derived store is not supported",L),SR(W,".on",z,J,L)),off(z){let J=b(z).id,j=b(W).family.links.find((I)=>I.meta.onTrigger===J);return j&&X_(j),W},map(z,J){let j,I;EO(z)&&(j=z,z=z.fn);let F=W.getState(),P=t(F);fO()?I=null:(!P||P&&X)&&(I=z(F));let C=XO(I,{name:`${W.shortName} → *`,derived:1,...J,and:j}),V=_0(W,C,xO,z_,z);return W_(OO(C),{type:xO,fn:z,from:D}),OO(C).noInit=1,e("storeMap",D,V),C},watch(z,J){if(GO(!J,"watch second argument","sample",L),!J||!_O(z)){let j=eR(W,z);return e("storeWatch",D,z)||z(W.getState()),j}return S(n(J),"second argument should be a function",L),z.watch((j)=>J(W.getState(),j))}},A=RR("store",W,E,CO(XO)),K=W.defaultConfig.updateFilter;W.graphite=p({scope:{state:D,fn:K},node:[c((z,J,j)=>(j.scope&&!j.scope.reg[D.id]&&(j.b=1),z)),MO(D),c((z,J,{a:j,b:I})=>{let F=t(z);return F&&!H&&lR(`${G_}`,W.graphite),(F&&X||!F)&&(z!==j||I)},1),K&&YO(aR,1),BO({from:"stack",target:D})],child:B,meta:{...A,defaultState:O,stateRef:D},regional:1}),r(W,"id",W.graphite.id),r(W,"rootStateRefId",Z);let U=s(W,"serialize"),Q=s(W,"derived"),M=U==="ignore",Y=s(W,"sid");Y&&(r(W,"storeChange",1),D.sid=Y),Y||M||Q||r(W,"warnSerialize",1);let q=t(O);return S(Q||!q||q&&X,G_,L),Q&&q&&!H&&console.error(`${L}: ${G_}`),QO(W,[B]),E!=null&&E.domain&&E.domain.hooks.store(W),Q||(W.reinit=d({named:"reinit"}),W.reset(W.reinit)),D.meta=W.graphite.meta,o_(W.graphite),W}function cO(...O){let _,E,D;[O,D]=wO(O);let L=a("combine",D),B=O[O.length-1],Z=O.length>1&&!i(B)&&EO(B),H=Z&&B,X=Z?O[O.length-2]:B,W,A,K;if(n(X)?(E=O.slice(0,Z?-2:-1),_=X):E=O,E.length===1){let U=E[0];i(U)||(W=U,A=1)}if(!A&&(W=E,_)){K=1;let U=_;_=(Q)=>U(...Q)}return S(EO(W),`${L}: shape should be an object`),u0(Array.isArray(W),!K,W,CO(cO),D,_,H)}function pR(){let O={};return O.req=new Promise((_,E)=>{O.rs=_,O.rj=E}),O.req.catch(()=>{}),O}function c_(O,_={}){let E=IO(n(O)?{handler:O}:O,_),D=a("effect",E),L=d(n(O)?{handler:O}:O,{..._,actualOp:"effect"});aO(L,CO(c_));let B=b(L);r(B,"op",L.kind="effect"),L.use=(M)=>(S(n(M),".use argument should be a function",D),K.scope.handler=M,L),L.use.getCurrent=()=>K.scope.handler;let Z=L.finally=d({named:"finally",derived:1}),H=L.done=Z.filterMap({named:"done",fn({status:M,params:Y,result:q}){if(M==="done")return{params:Y,result:q}}}),X=L.fail=Z.filterMap({named:"fail",fn({status:M,params:Y,error:q}){if(M==="fail")return{params:Y,error:q}}}),W=L.doneData=H.map({named:"doneData",fn:({result:M})=>M}),A=L.failData=X.map({named:"failData",fn:({error:M})=>M}),K=p({scope:{handler:L.defaultConfig.handler||(()=>S(0,`no handler used in ${L.compositeName.fullName}`))},node:[c((M,Y,q)=>{let z=Y.handler,J=qO(q);if(J){let j=J.handlers.unitMap.get(L)||J.handlers.sidMap[L.sid];j&&(z=j)}return M.handler=z,M},0,1),c((M,Y,q)=>{if(Y.runnerFn&&!Y.runnerFn(M,null,q))return;let{params:z,req:J,handler:j,args:I=[z]}=M,F=U_(z,J,1,Z,q),P=U_(z,J,0,Z,q),[C,V]=R0(j,P,I);C&&(EO(V)&&n(V.then)?V.then(F,P):F(V))},0,1)],meta:{op:"fx",fx:"runner"},regional:1});B.scope.runner=K,m(B.seq,c((M,{runner:Y},q)=>{let z=RO(q)?{params:M,req:{rs(J){},rj(J){}}}:M;return q.meta||(q.meta={fxID:v0()}),HO({target:Y,params:z,defer:1,scope:qO(q),meta:q.meta}),z.params})),L.create=(M)=>{let Y=pR(),q={params:M,req:Y};if(u&&!B_){let z=u;Y.req.finally(()=>{M_(z)}).catch(()=>{})}return HO({target:L,params:q,scope:u}),Y.req};let U=L.inFlight=XO(0,{serialize:"ignore",named:(s(L,"name")||L.graphite.id)+".inFlight"}).on(L,(M)=>M+1).on(Z,(M)=>M-1).map({fn:(M)=>M,named:"inFlight"});r(Z,"needFxCounter","dec"),r(L,"needFxCounter",1);let Q=L.pending=U.map({fn:(M)=>M>0,named:"pending"});return QO(L,[Z,H,X,W,A,Q,U]),E!=null&&E.domain&&E.domain.hooks.effect(L),L}function C0(O){let _;[O,_]=wO(O,1);let E=a("attach",_),{source:D,effect:L,mapParams:B,domain:Z}=O;$O(L)&&S(t(Z),"`domain` can only be used with a plain function",E);let H=c_(O,_);r(H,"attached",1),aO(H,CO(C0));let{runner:X}=b(H).scope,W,A=(U,Q,M)=>{let{params:Y,req:q,handler:z}=U,J=H.finally,j=U_(Y,q,0,J,M),I=M.a,F=$O(z),P,C=1;if(B?[C,P]=R0(B,j,[Y,I]):P=D&&F?I:Y,C){if(!F)return U.args=[I,P],1;HO({target:z,params:{params:P,req:{rs:U_(Y,q,1,J,M),rj:j}},page:M.page,defer:1,meta:M.meta})}};if(D){let U;X.scope.runnerFn=A,i(D)?(U=D,QO(U,[H])):(U=cO(D),QO(H,[U])),W=[c((Q)=>Q,0,1),MO(OO(U))],delete X.seq[1].order}else W=[c(A,1,1)];X.seq.splice(1,0,...W),H.use(L);let K=RO(L);return K&&(Object.assign(Q_(H),p_(H.shortName,K)),H.defaultConfig.parent=K),_R(L,H,"effect"),H}function n0(...O){let[[_,E],D]=wO(O),L={};return WO(E,(B,Z)=>{let H=L[Z]=d(Z,{parent:RO(_),config:D});_.on(H,B),_R(_,H)}),L}function fR(O,_){let E=IO({or:_,and:typeof O=="string"?{name:O}:O}),D=p({family:{type:"domain"},regional:1,parent:(E==null?void 0:E.domain)||(E==null?void 0:E.parent)}),L={history:{},graphite:D,hooks:{}};D.meta=RR("domain",L,{parent:(E==null?void 0:E.domain)||(E==null?void 0:E.parent),or:{...E,derived:1}},CO(fR)),WO({Event:d,Effect:c_,Store:XO,Domain:fR},(Z,H)=>{let X=H.toLowerCase(),W=d({named:`on${H}`});L.hooks[X]=W;let A=new Set;L.history[`${X}s`]=A,W.create=(K)=>(HO(W,K),K),m(b(W).seq,c((K,U,Q)=>(Q.scope=null,K))),W.watch((K)=>{QO(L,[K]),A.add(K),K.ownerSet||(K.ownerSet=A),RO(K)||(K.parent=L)}),QO(L,[W]),L[`onCreate${H}`]=(K)=>(h(A,K),W.watch(K)),L[`create${H}`]=L[X]=(K,U)=>{let Q=IO({and:U,or:K});return Q!=null&&Q.domain?Z(K,U):W(Z(K,{parent:L,or:Q}))}});let B=RO(L);return B&&WO(L.hooks,(Z,H)=>AO(Z,B.hooks[H])),E!=null&&E.domain&&E.domain.hooks.domain(L),L}function a0(O){n_(O);let _=m_ in O?O[m_]():O;S(_.subscribe,"expect observable to have .subscribe");let E=d(),D=OR(E);return _.subscribe({next:E,error:D,complete:D}),E}function cR(O,_){let E=0;return h(h0,(D)=>{D in O&&(S(O[D]!=null,E0(_,D)),E=1)}),E}function F0(...O){let _,E,D,L,[[B,Z,H],X]=wO(O),W=1,A=a("sample",X);return t(Z)&&EO(B)&&cR(B,A)&&(Z=B.clock,H=B.fn,("batch"in B)?W=B.batch:(GO(!("greedy"in B),"greedy in sample","batch",A),W=!B.greedy),L=B.filter,_=B.target,E=B.name,D=B.sid,B=B.source),ER("sample",Z,B,L,_,H,E,X,W,1,0,D)}function r0(...O){let[[_,E],D]=wO(O),L=a("guard",D);return GO(0,"guard","sample",L),E||(E=_,_=E.source),cR(E,L),ER("guard",E.clock,_,E.filter,E.target,null,E.name,D,!E.greedy,0,1)}function t0(O,_){let E=a("merge",_);gO(O,E,"first argument");let D=d({name:sR(O,"merge"),derived:1,and:_});return AO(O,D,[],"merge"),D}function e0(O,_,E){let D=a("restore",E);if(S(!i(O),"restore($store) is not supported",D),i_(O)||$O(O)){let B=RO(O),Z=XO(_,{parent:B,name:O.shortName,and:E});return AO($O(O)?O.doneData:O,Z),B&&B.hooks.store(Z),Z}let L=Array.isArray(O)?[]:{};return WO(O,(B,Z)=>L[Z]=i(B)?B:XO(B,{name:Z})),L}function T0(...O){let E,D,[[L,B],Z]=wO(O),H=a("split",Z),X=!B;X&&(E=L.cases,B=L.match,D=L.clock,L=L.source);let W=i(B),A=!_O(B)&&n(B),K=!W&&!A&&EO(B);S(_O(L),"source must be a unit",H),E||(E={}),X?WO(E,(z,J)=>a_(H,z,`cases.${J}`)):(S(K,"match should be an object",H),WO(B,(z,J)=>E[J]=d({derived:1,named:`cases.${J}`,and:Z})),E.__=d({derived:1,named:"cases.__",and:Z}));let U=new Set([].concat(L,D||[],Object.values(E))),Q=Object.keys(W||A?E:B),M,Y;if(W||A)W&&U.add(B),M=[W&&MO(OO(B),0,1),PO({safe:W,filter:1,pure:!W,fn(z,J,j){let I=String(W?j.a:B(z));f_(J,zO(Q,I)?I:"__",z,j)}})];else if(K){let z=Y=VO({});z.type="shape";let J=[],j;WO(B,(I,F)=>{if(_O(I)){j=1,m(J,F),U.add(I);let P=AO(I,[],[MO(z),c((C,V,{a:l})=>l[F]=C)]);if(i(I)){z.current[F]=I.getState();let C=OO(I);W_(z,{from:C,field:F,type:"field"}),e("splitMatchStore",C,P)}}}),j&&e("splitBase",z),M=[j&&MO(z,0,1),YO((I,F,P)=>{for(let C=0;C<Q.length;C++){let V=Q[C];if(zO(J,V)?P.a[V]:B[V](I))return void f_(F,V,I,P)}f_(F,"__",I,P)},1)]}else S(0,"expect match to be unit, function or object");let q=p({meta:{op:"split",stateRef:Y},parent:D?[]:L,scope:E,node:M,family:{owners:Array.from(U)},regional:1});if(D&&ER("split",D,L,null,q,null,"split",Z,0,0,0),aO(q,CO(T0)),!X)return E}function O1(O,{scope:_,params:E}={}){if(!_O(O))return Promise.reject(Error("first argument should be unit"));if(!($O(O)||i_(O)||i(O)||sO(O)))return Promise.reject(Error("first argument accepts only effects, events, stores or scopes"));if(sO(O))_=O;else if(!l_(O)){let H=a("allSettled",b(O).meta);return Promise.reject(Error(`${H}: unit should be targetable`))}let D=pR();D.parentFork=u;let{fxCount:L}=_;m(L.scope.defers,D);let B=[],Z=[];return sO(O)||(m(B,O),m(Z,$O(O)?{params:E,req:{rs(H){D.value={status:"done",value:H}},rj(H){D.value={status:"fail",value:H}}}}:E)),m(B,L),m(Z,null),HO({target:B,params:Z,scope:_}),D.req}function iR(O,_,E){let D=[];(function L(B){zO(D,B)||(m(D,B),s(B,"op")==="store"&&(E||s(B,"sid"))&&_(B,s(B,"sid")),h(B.next,L),h(iO(B),L),h(lO(B),L))})(O)}function u_(O,_){let E=Array.isArray(O)?new Map(O):O,D=new Map,L=0;if(E instanceof Map){let B={};return h(E,(Z,H)=>{S(_O(H),"Map key should be a unit"),_&&_(H,Z),H.sid&&((H.sid in B)&&(L=1),B[H.sid]=Z),D.set(H,Z)}),{sidMap:B,unitMap:D,hasSidDoubles:L}}return{sidMap:E,unitMap:D}}function _1(O,_){let E,D=O;nO(O)&&(GO(0,"fork(domain)","fork()"),E=O,D=_);let L=((B)=>{let Z=p({scope:{defers:[],inFlight:0,fxID:0},node:[c((A,K,U)=>{U.parent?U.parent.node.meta.needFxCounter==="dec"?K.inFlight-=1:(K.inFlight+=1,K.fxID+=1):K.fxID+=1}),PO({priority:"sampler",batch:1}),c((A,K)=>{let{defers:U,fxID:Q}=K;K.inFlight>0||U.length===0||Promise.resolve().then(()=>{K.fxID===Q&&h(U.splice(0,U.length),(M)=>{M_(M.parentFork),M.rs(M.value)})})},0,1)]}),H=p({node:[c((A,K,U)=>{let Q=U.parent;if(Q){let M=Q.node;if(dR(Q)){let Y=qO(U),q=M.meta.sid;Y.sidIdMap[q]=M.scope.state.id,Y.values.sidMap[q]=A;let z=M.meta.serialize;z&&Y.sidSerializeSettings.set(q,z==="ignore"?{ignore:1}:{ignore:0,write:z.write})}}})]}),X=p({node:[c((A,K,U)=>{let Q=qO(U),M=U.parent;Q&&M&&dR(M)&&Q.warnSerializeNodes.add(M.node)})]}),W={cloneOf:B,reg:{},values:{sidMap:{},idMap:{}},sidIdMap:{},sidSerializeSettings:new Map,getState(A){if("current"in A)return d_(ZO,W,A,0).current;let K=b(A);return d_(ZO,W,K.scope.state,1).current},kind:"scope",graphite:p({family:{type:"domain",links:[Z,H,X]},meta:{unit:"fork"},scope:{forkInFlightCounter:Z}}),additionalLinks:{},handlers:{sidMap:{},unitMap:new Map},fxCount:Z,storeChange:H,warnSerializeNodes:new Set,warnSerializeNode:X};return W})(E);if(D){if(D.values){let{sidMap:B,unitMap:Z,hasSidDoubles:H}=u_(D.values,(X)=>S(i(X)&&l_(X),"Values map can contain only writable stores as keys"));Object.assign(L.values.sidMap,B),h(Z,(X,W)=>{if(L.values.idMap[W.stateRef.id]=X,L.sidIdMap[s(W,"sid")]=W.stateRef.id,s(W,"serialize")==="ignore"){let A=s(W,"sid");L.sidSerializeSettings.set(A,{ignore:1})}}),L.fromSerialize=!(Array.isArray(D.values)||D.values instanceof Map),L.hasSidDoubles=H}D.handlers&&(GO(D.handlers instanceof Map||Array.isArray(D.handlers),"object with handlers","array"),L.handlers=u_(D.handlers,(B)=>S($O(B),"Handlers map can contain only effects as keys")))}return L}function R1(O,{values:_}){S(EO(_),"values property should be an object");let{sidMap:E,unitMap:D}=u_(_),L=Object.getOwnPropertyNames(E),B={};h(D,(K,U)=>{B[U.stateRef.id]=U});let Z=[],H=[],X,W,A;sO(O)?(X=O,A=1,S(X.cloneOf,"scope should be created from domain"),GO(0,"hydrate(fork(domain), { values })","fork({ values })"),W=b(X.cloneOf)):nO(O)?(GO(0,"hydrate(domain, { values })","fork({ values })"),W=b(O)):S(0,"first argument of hydrate should be domain or scope"),iR(W,(K,U)=>{if(U&&zO(L,U)){m(Z,K);let Q=s(K,"serialize");Q&&Q!=="ignore"&&(E[U]=Q.read(E[U])),m(H,E[U])}else K.scope.state.id in B&&(m(Z,K),m(H,D.get(B[K.scope.state.id])))},1),HO({target:Z,params:H,scope:X}),A&&Object.assign(X.values.sidMap,E)}function K_(O,{scope:_,safe:E}={}){S(_||u||E,"scopeBind: scope not found");let D=_||u;return(...L)=>{function B(){M_(X)}let Z,H=0,X=u;M_(D);try{Z=O(...L)}catch(W){Z=W,H=1}if(B(),H)throw Z;return Z instanceof Promise&&Z.then(B,B),Z}}function E1(O,_={}){O.warnSerializeNodes.size&&(console.error("serialize: One or more stores dont have sids, their values are omitted"),h(O.warnSerializeNodes,(L)=>{lR("store should have sid or `serialize: ignore`",L)})),S(!O.hasSidDoubles,"duplicate sid found in this scope");let E=_.ignore?_.ignore.map(({sid:L})=>L):[],D={};return WO(O.values.sidMap,(L,B)=>{var Z;if(zO(E,B))return;let H=O.sidIdMap[B],X=(Z=O.sidSerializeSettings.get(B))!==null&&Z!==void 0?Z:{ignore:0,write:b0};X.ignore||(D[B]=(0,X.write)(H&&H in O.reg?O.reg[H].current:L))}),"onlyChanges"in _&&(GO(0,"onlyChanges"),_.onlyChanges||(S(O.cloneOf,"scope should be created from domain"),iR(b(O.cloneOf),(L,B)=>{B in D||zO(E,B)||s(L,"isCombine")||s(L,"serialize")==="ignore"||(D[B]=O.getState(L))}))),D}function Y_({unit:O,fn:_,scope:E,batch:D}){let L=[D_.run({fn:(Z)=>_(Z)})];D&&L.unshift(D_.compute({priority:"sampler",batch:1})),i(O)&&L.unshift(D_.mov({store:O.stateRef,to:"stack"}));let B=Array.isArray(O)?O:[O];if(E){let Z=[],H=E.additionalLinks;return B.forEach((X)=>{let W=H[X.graphite.id]||[];H[X.graphite.id]=W;let A=p({node:P0(L,X),meta:{watchOp:X.kind}});W.push(A),Z.push(()=>{let K=W.indexOf(A);K!==-1&&W.splice(K,1),X_(A)})}),k_(()=>{Z.forEach((X)=>X())})}{let Z=p({node:L,parent:B,family:{owners:B}});return k_(()=>{X_(Z)})}}function P0(O,_){return i(_)?[D_.mov({store:_.stateRef,to:"stack"}),...O]:O}var m_=typeof Symbol<"u"&&Symbol.observable||"@@observable",xO="map",b=(O)=>O.graphite||O,iO=(O)=>O.family.owners,lO=(O)=>O.family.links,OO=(O)=>O.stateRef,dO=(O)=>O.value,RO=(O)=>O.parent,qO=(O)=>O.scope,s=(O,_)=>b(O).meta[_],r=(O,_,E)=>b(O).meta[_]=E,Q_=(O)=>O.compositeName,_O=(O)=>(n(O)||EO(O))&&("kind"in O),oO=(O)=>(_)=>_O(_)&&_.kind===O,i=oO("store"),i_=oO("event"),$O=oO("effect"),l_=(O)=>_O(O)&&!!O.targetable,nO=oO("domain"),sO=oO("scope"),UO={__proto__:null,unit:_O,store:i,event:i_,effect:$O,targetable:l_,domain:nO,scope:sO,attached:(O)=>$O(O)&&s(O,"attached")==1},zO=(O,_)=>O.includes(_),v_=(O,_)=>{let E=O.indexOf(_);E!==-1&&O.splice(E,1)},m=(O,_)=>O.push(_),GO=(O,_,E,D)=>!O&&console.error(`${D?D+": ":""}${_} is deprecated${E?`, use ${E} instead`:""}`),lR=(O,_)=>{let E=s(_,"unitTrace"),D=s(_,"config"),L=D!=null&&D.loc?` at ${D.loc.file}`:null,B=D==null?void 0:D.name,Z=O;B&&(Z=`${B}: ${O}`),L&&(Z=`${B}${L}: ${O}`);let H=Error(Z);E&&(H.stack=E),E||B||L||console.log(`Add effector's Babel or SWC plugin to your config for more detailed debug information or "import "effector/enable_debug_traces" to your code entry module to see full stack traces`),console.error(H)},A_=()=>{let O=0;return()=>""+ ++O},V0=A_(),oR=A_(),N0=A_(),v0=A_(),h_,L1=(O)=>{h_=O},o=null,o_=(O)=>{h_&&h_(O,o)},fO=()=>o&&o.template,nR=(O)=>(O&&o&&o.sidRoot&&(O=`${o.sidRoot}|${O}`),O),D1=({sid:O,name:_,loc:E,method:D,fn:L})=>w0(p({meta:{sidRoot:nR(O),sid:O,name:_,loc:E,method:D,type:"factory"},regional:1}),L),QO=(O,_)=>{let E=b(O);h(_,(D)=>{let L=b(D);E.family.type!=="domain"&&(L.family.type="crosslink"),m(iO(L),E),m(lO(E),L)})},yO=(O=[])=>(Array.isArray(O)?O:[O]).flat().map(b),EO=(O)=>typeof O=="object"&&O!==null,n=(O)=>typeof O=="function",t=(O)=>O===void 0,n_=(O)=>S(EO(O)||n(O),"expect first argument be an object"),kR=(O,_,E,D)=>S(!(!EO(O)&&!n(O)||!("family"in O)&&!("graphite"in O)),`${_}: expect ${E} to be a unit (store, event or effect)${D}`),gO=(O,_,E)=>{Array.isArray(O)?h(O,(D,L)=>kR(D,_,`${L} item of ${E}`,"")):kR(O,_,E," or array of units")},a_=(O,_,E="target")=>h(yO(_),(D)=>S(!s(D,"derived"),`${O}: derived unit in "${E}" is not supported, use createStore/createEvent instead"`)),aR=(O,{fn:_},{a:E})=>_(O,E),x0=(O,{fn:_},{a:E})=>_(E,O),z_=(O,{fn:_})=>_(O),rR=(O,_,E,D)=>{let L={id:oR(),type:O,data:_};return E&&(L.order={priority:E},D&&(L.order.barrierID=++g0)),L},g0=0,BO=({from:O="store",store:_,target:E,to:D=E?"store":"stack",batch:L,priority:B})=>rR("mov",{from:O,store:_,to:D,target:E},B,L),PO=({fn:O,batch:_,priority:E,safe:D=0,filter:L=0,pure:B=0})=>rR("compute",{fn:O,safe:D,filter:L,pure:B},E,_),r_=({fn:O})=>PO({fn:O,priority:"effect"}),c=(O,_,E)=>PO({fn:O,safe:1,filter:_,priority:E&&"effect"}),MO=(O,_,E)=>BO({store:O,to:_?"stack":"a",priority:E&&"sampler",batch:1}),YO=(O=z_,_)=>PO({fn:O,pure:1,filter:_}),D_={mov:BO,compute:PO,filter:({fn:O,pure:_})=>PO({fn:O,filter:1,pure:_}),run:r_},VO=(O)=>({id:oR(),current:O,initial:O}),pO=({current:O})=>O,W_=(O,_)=>{O.before||(O.before=[]),m(O.before,_)},vO=null,t_=(O,_)=>{if(!O)return _;if(!_)return O;let E;return(O.v.type===_.v.type&&O.v.id>_.v.id||y_(O.v.type)>y_(_.v.type))&&(E=O,O=_,_=E),E=t_(O.r,_),O.r=O.l,O.l=E,O},e_=[],uR=0;for(;uR<6;)m(e_,{first:null,last:null,size:0}),uR+=1;var S0=()=>{for(let O=0;O<6;O++){let _=e_[O];if(_.size>0){if(O===3||O===4){_.size-=1;let D=vO.v;return vO=t_(vO.l,vO.r),D}_.size===1&&(_.last=null);let E=_.first;return _.first=E.r,_.size-=1,E.v}}},TO=(O,_,E,D,L,B,Z)=>b_(0,{a:null,b:null,node:E,parent:D,value:L,page:_,scope:B,meta:Z},O,0),b_=(O,_,E,D)=>{let L=y_(E),B=e_[L],Z={v:{idx:O,stack:_,type:E,id:D},l:null,r:null};L===3||L===4?vO=t_(vO,Z):(B.size===0?B.first=Z:B.last.r=Z,B.last=Z),B.size+=1},y_=(O)=>{switch(O){case"child":return 0;case"pure":return 1;case"read":return 2;case"barrier":return 3;case"sampler":return 4;case"effect":return 5;default:return-1}},x_=new Set,u,E_=1,B_=0,Z_=0,ZO=null,M_=(O)=>{u=O},mR=(O)=>{ZO=O},tR=(O,_)=>{if(O){for(;O&&!O.reg[_];)O=O.parent;if(O)return O}return null},d_=(O,_,E,D)=>{let L=tR(O,E.id);return L?L.reg[E.id]:_?(SO(_,E,D),_.reg[E.id]):E},s_,B1=(O)=>{s_=O},f0=(O)=>O,SO=(O,_,E,D,L)=>{let B=O.reg;if(B[_.id])return;let Z=_.sid,H={id:_.id,current:_.initial,meta:_.meta};if(H.id in O.values.idMap)H.current=O.values.idMap[H.id];else if(Z&&Z in O.values.sidMap&&!(Z in O.sidIdMap)){var X;let W=_==null||(X=_.meta)===null||X===void 0?void 0:X.serialize;H.current=(O.fromSerialize&&W!=="ignore"&&(W==null?void 0:W.read)||f0)(O.values.sidMap[Z])}else if(_.before&&!L){let W=0,A=E||!_.noInit||D;h(_.before,(K)=>{switch(K.type){case"map":{let U=K.from;if((U||K.fn)&&(U&&SO(O,U,E,D),A)){let Q=U&&B[U.id].current;H.current=K.fn?K.fn(Q):Q}break}case"field":SO(O,K.from,E,D),W||(W=1,H.current=Array.isArray(H.current)?[...H.current]:{...H.current}),A&&(H.current[K.field]=B[B[K.from.id].id].current)}})}Z&&(O.sidIdMap[Z]=_.id),B[_.id]=H},k0=(O,_,E)=>{try{return _(dO(E),O.scope,E)}catch(D){console.error(D),O.fail=1,O.failReason=D}},IO=(O,_={})=>(EO(O)&&(IO(O.or,_),WO(O,(E,D)=>{t(E)||D==="or"||D==="and"||(_[D]=E)}),IO(O.and,_)),_),hR=(O,_)=>{v_(O.next,_),v_(iO(O),_),v_(lO(O),_)},bR=["on","reset","sample","split","merge","guard","forward"],H_=(O,_,E,D,L)=>{let B;O.next.length=0,O.seq.length=0,O.scope=null;let Z=lO(O),{stateRef:H,defaultShape:X,isRegion:W,op:A}=O.meta;if(H&&(H.before=[],O.meta.stateRef=null),X)for(let U in X)X[U]=null;let K=W?O:D;if(Z.length>0){let U=zO(bR,A),Q=!W&&!L,M=Q&&E&&!U;for(;B=Z.pop();){let Y=zO(B.next,O);hR(B,O),W&&H_(B,0,0,O,1),Y||(B.family.triggers-=1),(_||M||Q&&B.family.type==="crosslink"&&!U||L&&zO(bR,B.meta.op)&&(Y&&B.next.length===0||!Y&&B.family.triggers<=0))&&H_(B,_,E&&B.meta.op!=="on",K,L)}}for(Z=iO(O);B=Z.pop();)hR(B,O),E&&B.family.type==="crosslink"&&H_(B,_,B.meta.op!=="on",K,L)},L_=(O)=>O.clear(),X_=(O,{deep:_}={})=>{let E=0;if(O.ownerSet&&O.ownerSet.delete(O),nO(O)){E=1;let D=O.history;L_(D.events),L_(D.effects),L_(D.stores),L_(D.domains)}H_(b(O),!!_,E,null,0)},OR=(O)=>k_(()=>X_(O)),AO=(O,_,E,D,L)=>p({node:E,parent:O,child:_,scope:{fn:L},meta:{op:D},family:{owners:[O,_],links:_},regional:1}),Z1=(O)=>{let[{from:E,to:D},L]=wO(O,1),B=a("forward",L);return GO(0,"forward","sample",B),gO(E,B,'"from"'),gO(D,B,'"to"'),a_(B,D,"to"),OR(p({parent:E,child:D,meta:{op:"forward",config:L},family:{},regional:1}))},eR=(O,_)=>(S(n(_),".watch argument should be a function"),OR(p({scope:{fn:_},node:[r_({fn:z_})],parent:O,meta:{op:"watch"},family:{owners:O},regional:1}))),O0=0,_R=(O,_,E="event")=>{RO(O)&&RO(O).hooks[E](_)},aO=(O,_)=>r(O,"unitTrace",_),CO=(O)=>{if(!O0)return"";let _=Error("unit trace");return Error.captureStackTrace&&Error.captureStackTrace(_,O),_.stack},RR=(O,_,E,D)=>{let L=IO(E),B=O==="domain",Z=V0(),{sid:H=null,named:X=null,domain:W=null,parent:A=W}=L,K=X||L.name||(B?"":Z),U=p_(K,A),Q={op:_.kind=O,name:_.shortName=K,sid:_.sid=nR(H),named:X,unitId:_.id=Z,serialize:L.serialize,derived:L.derived,config:L,unitTrace:D};if(_.targetable=!L.derived,_.parent=A,_.compositeName=U,_.defaultConfig=L,_.getType=()=>(GO(0,"getType","compositeName.fullName"),U.fullName),!B){_.subscribe=(Y)=>(n_(Y),_.watch(n(Y)?Y:(q)=>Y.next&&Y.next(q))),_[m_]=()=>_;let M=fO();M&&(Q.nativeTemplate=M)}return Q},g_=(O,_,E,D)=>{let L;EO(E)&&(L=E,E=E.fn);let B=d({name:`${O.shortName} → *`,derived:1,and:L});return AO(O,B,D,_,E),B},G_="undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option",_0=(O,_,E,D,L)=>{let B=OO(_),Z=BO({store:B,to:"a",priority:"read"});E===xO&&(Z.data.softRead=1);let H=[Z,YO(D)];e("storeOnMap",B,H,i(O)&&OO(O));let X=AO(O,_,H,E,L);return E!==xO&&r(X,"onTrigger",b(O).id),X},u0=(O,_,E,D,L,B,Z)=>{let H=a("combine",L),X=O?(J)=>[...J]:(J)=>({...J}),W=O?[]:{},A=X(W),K=VO(A),U=VO(1);K.type=O?"list":"shape",K.noInit=1,e("combineBase",K,U);let Q=XO(A,{name:sR(E),derived:1,...Z,and:L});aO(Q,D);let M=OO(Q);M.noInit=1,r(Q,"isCombine",1),QO(Q,[p({meta:{stateRef:K}})]);let Y=MO(K);Y.order={priority:"barrier"};let q=BO({store:M,to:"b",priority:"read"});q.data.softRead=1;let z=[c((J,j,I)=>(I.scope&&!I.scope.reg[K.id]&&(I.c=1),J)),Y,BO({store:U,to:"b"}),c((J,{key:j},I)=>{if(I.c||J!==I.a[j])return _&&I.b&&(I.a=X(I.a)),I.a[j]=J,1},1),BO({from:"a",target:K}),BO({from:"value",store:0,target:U}),BO({from:"value",store:1,target:U,priority:"barrier",batch:1}),MO(K,1,1),B&&YO(),q];if(WO(E,(J,j)=>{if(!i(J))return S(!_O(J)&&!t(J),`combine expects a store in a field ${j}`,H),void(A[j]=W[j]=J);W[j]=J.defaultState,A[j]=J.getState();let I=AO(J,Q,z,"combine",B);I.scope.key=j;let F=OO(J);W_(K,{type:"field",field:j,from:F}),e("combineField",F,I)}),Q.defaultShape=E,r(Q,"defaultShape",E),W_(M,{type:xO,from:K,fn:B}),!fO())if(B){let J=B(A);!t(J)||Z&&"skipVoid"in Z||console.error(`${H}: ${G_}`),M.current=J,M.initial=J,Q.defaultState=J}else Q.defaultState=W;return Q},R0=(O,_,E)=>{try{return[1,O(...E)]}catch(D){return _(D),[0,null]}},U_=(O,_,E,D,L)=>(B)=>{HO({target:[D,m0],params:[E?{status:"done",params:O,result:B}:{status:"fail",params:O,error:B},{value:B,fn:E?_.rs:_.rj}],defer:1,page:L.page,scope:L.scope,meta:L.meta})},m0=p({node:[r_({fn:({fn:O,value:_})=>O(_)})],meta:{op:"fx",fx:"sidechain"}}),h0=["source","clock","target"],E0=(O,_)=>O+`: ${_} should be defined`,ER=(O,_,E,D,L,B,Z,H,X,W,A,K)=>{let U=a(O,H),Q=!!L;S(!t(E)||!t(_),E0(U,"either source or clock"));let M=0;t(E)?M=1:_O(E)||(E=cO(E)),t(_)?_=E:(gO(_,U,"clock"),Array.isArray(_)&&(_=AO(_,[],[],O))),M&&(E=_),H||Z?H&&Z?H.name=Z:!H&&Z&&(H={name:Z}):Z=E.shortName;let Y="none";(A||D)&&(_O(D)?Y="unit":(S(n(D),"`filter` should be function or unit"),Y="fn")),L?(gO(L,U,"target"),a_(U,L)):Y==="none"&&W&&i(E)&&i(_)?L=XO(B?B(pO(OO(E)),pO(OO(_))):pO(OO(E)),{name:Z,sid:K,or:H}):(L=d({name:Z,derived:1,or:H}),e("sampleTarget",b(L)));let q=VO(),z=[],J=[];if(Y==="unit"){let[F,P,C,V]=yR(D,L,_,q,O);V&&m(J,V),C||z.push(...S_(P)),z.push(...S_(F))}let j=[];if(M)X&&m(j,MO(q,1,1));else{let[F,P,C,V]=yR(E,L,_,q,O);V&&m(J,V),C||j.push(...S_(P)),m(j,MO(F,1,X))}let I=AO(_,L,[e("sampleSourceLoader"),BO({from:"stack",target:q}),...j,...z,MO(q),Y==="fn"&&YO((F,P,{a:C})=>D(F,C),1),B&&YO(aR),e("sampleSourceUpward",Q)],O,B);return QO(E,[I]),QO(I,J),Object.assign(I.meta,H,{joint:1,stateRef:q}),aO(I,CO(F0)),L},S_=(O)=>[MO(O),c((_,E,{a:D})=>D,1)],yR=(O,_,E,D,L)=>{let B=i(O),Z=B?OO(O):VO(),H=VO(B),X;return B||(X=p({parent:O,node:[BO({from:"stack",target:Z}),BO({from:"value",store:1,target:H})],family:{owners:[...new Set([O,_,E].flat())],links:_},meta:{op:L},regional:1})),e("sampleSource",H,Z,D),[Z,H,B,X]},f_=(O,_,E,D)=>{let L=O[_];L&&HO({target:L,params:Array.isArray(L)?L.map(()=>E):E,defer:1,stack:D})},H1="23.4.4",dR=(O)=>!O.node.meta.isCombine||O.parent&&O.parent.node.meta.op!=="combine",b0=(O)=>O,G1={setDebugTraces:(O)=>{O0=O,O&&console.log("[effector/debug_traces] Debug traces enabled")}};var f=bO(J_(),1);var G0=bO(L0(),1),W0=bO(LR(),1);function j_(O,_){return _.displayName=O,_}function HR(O,_){let E=UO.unit(O),D={};E?D={unit:O}:("@@unitShape"in O)?typeof O["@@unitShape"]=="function"?D=O["@@unitShape"]():KO("expect @@unitShape to be a function"):D=O;let L=Array.isArray(D),B=f.default.useRef({stale:1,justSubscribed:0,scope:_}),[Z,H,X,W,A]=f.default.useMemo(()=>{B.current.stale=1;let M=Array.isArray(D)?[]:{},Y=[],q=[],z=[],J=[];for(let j in D){if(!{}.hasOwnProperty.call(D,j))continue;let I=D[j];UO.unit(I)||KO(`expect useUnit ${E?"argument":`value in key "${j}"`} to be a unit`),UO.event(I)||UO.effect(I)?(M[j]=_?K_(I,{scope:_}):I,z.push(j),J.push(I)):(M[j]=null,Y.push(j),q.push(I))}return[M,Y,q,z,J]},[B,_,...Object.keys(D),...Object.values(D)]),K=f.default.useRef({value:Z,storeKeys:H,eventKeys:W,eventValues:A}),U=f.default.useCallback((M)=>{let Y=B.current;return Y.justSubscribed=1,Y_({unit:X,fn:()=>{Y.stale||(Y.stale=1,M())},scope:_,batch:1})},[X,_,K,B]),Q=f.default.useCallback(()=>{let M=K.current,Y=B.current,q,z=0,J=M.value,j=M.storeKeys,I=M.eventKeys,F=M.eventValues,P=_!==Y.scope;if(Y.stale||Y.justSubscribed||P){z=!Y.justSubscribed||P,q=L?[...Z]:{...Z},j.length===H.length&&I.length===W.length||(z=1);for(let C=0;C<H.length;C++){let V=GR(X[C],_),l=H[C];z||(z=j.includes(l)?J[l]!==V:1),q[l]=V}for(let C=0;C<W.length;C++){let V=A[C],l=W[C];z||(z=I.includes(l)?F[I.indexOf(l)]!==V:1)}}return z&&(M.value=q),M.storeKeys=H,M.eventKeys=W,M.eventValues=A,Y.stale=0,Y.justSubscribed=!z,Y.scope=_,E?M.value.unit:M.value},[U,X,A,_,K,B]);return X0(U,Q,Q)}function DR([O,_],E){let D,L,B,Z,H=D0;_?(D=_,B=O,Z=[]):{fn:D,store:B,keys:Z,defaultValue:L,updateFilter:H=D0}=O,UO.store(B)||KO("useStoreMap expects a store"),Array.isArray(Z)||KO("useStoreMap expects an array as keys"),typeof D!="function"&&KO("useStoreMap expects a function");let X=f.default.useCallback((Q)=>Y_({unit:B,fn:Q,scope:E}),[B,E]),W=f.default.useCallback(()=>GR(B,E),[B,E]),A=f.default.useRef(),K=f.default.useRef(),U=f.default.useRef(Z);return i0(X,W,W,(Q)=>{if(A.current!==Q||!((M,Y)=>{if(!M||!Y||M.length!==Y.length)return 0;let q=1;for(let z=0;z<M.length;z++)if(M[z]!==Y[z]){q=0;break}return q})(U.current,Z)){let M=D(Q,Z);M===void 0&&L!==void 0&&(M=L),A.current=Q,U.current=Z,M!==void 0&&(K.current=M)}return K.current},(Q,M)=>!H(M,Q))}function B0(O,_={},E){let{open:D,close:L,set:B}=HR({open:O.open,close:O.close,set:O.set},E),Z=f.default.useMemo(()=>({open:D,close:L,set:B}),[O,D]),H=f.default.useRef({value:null,count:0});BR(()=>(Z.open(H.current.value),()=>Z.close(H.current.value)),[Z]),((X,W)=>{if(X===W)return 1;if(typeof X=="object"&&X!==null&&typeof W=="object"&&W!==null){let A=Object.keys(X),K=Object.keys(W);if(A.length!==K.length)return 0;for(let U=0;U<A.length;U++){let Q=A[U];if(X[Q]!==W[Q])return 0}return 1}return 0})(H.current.value,_)||(H.current.value=_,H.current.count+=1),BR(()=>{Z.set(H.current.value)},[H.current.count])}function FO(O){let _=f.default.useContext(U0);return O&&!_&&KO("No scope found, consider adding <Provider> to app root"),_}function ZE(O,_){return((E,D)=>{if(M0(1,"useEvent","useUnit"),!D)return E;let L=UO.unit(E)||typeof E!="object"?{event:E}:E;return f.default.useMemo(()=>{if(UO.unit(E))return K_(E,{scope:D});let B=Array.isArray(E)?[]:{};for(let Z in E)B[Z]=K_(E[Z],{scope:D});return B},[D,...Object.keys(L),...Object.values(L)])})(O,FO(_==null?void 0:_.forceScope))}function Z0(O,_){return((E,D)=>{M0(1,"useStore","useUnit"),UO.store(E)||KO("expect useStore argument to be a store");let L=f.default.useCallback((Z)=>Y_({unit:E,fn:Z,scope:D}),[E,D]),B=f.default.useCallback(()=>GR(E,D),[E,D]);return X0(L,B,B)})(O,FO(_==null?void 0:_.forceScope))}function HE(O,_){return HR(O,FO(_==null?void 0:_.forceScope))}function GE(O,_){return DR([O,_],FO(O==null?void 0:O.forceScope))}function WE(O,_,E){return((D,L,B)=>{let Z,H,X,W=[];typeof L=="object"&&L!==null?(L.keys&&(W=L.keys),{fn:Z,getKey:H,placeholder:X}=L):Z=L,UO.store(D)||KO("expect useList first argument to be a store"),typeof Z!="function"&&KO("expect useList's renderItem to be a function"),Array.isArray(W)||KO("expect useList's keys to be an array");let A=f.default.useMemo(()=>{let Q=j_(`${D.shortName||"Unknown"}.Item`,(M)=>{let{index:Y,keys:q,keyVal:z,value:J}=M;if(K.current[1])return K.current[0](J,z);let j=DR([{store:D,keys:[Y,...q],fn:(I,F)=>I[F[0]]}],B);return K.current[0](j,Y)});return f.default.memo(Q)},[D,B,!!H]),K=f.default.useRef([Z,H]);K.current=[Z,H];let U=f.default.useMemo(()=>W,W);if(H){let Q=HR(D,B);return Q.length===0&&X?X:Q.map((M)=>{let Y=K.current[1](M);return f.default.createElement(A,{keyVal:Y,key:Y,keys:U,value:M})})}{let Q=DR([{store:D,keys:[D],fn:(M)=>M.length}],B);return Q===0&&X?X:Array.from({length:Q},(M,Y)=>f.default.createElement(A,{index:Y,key:Y,keys:U}))}})(O,_,FO(E==null?void 0:E.forceScope))}function ME(O,_={},E){return B0(O,_,FO(E==null?void 0:E.forceScope))}function XE(){return FO()||null}function p0(O,_){function E(H){let X=f.default.useRef(H),W=Z0(D);BR(()=>(B({props:X.current,state:D.getState()}),()=>{Z({props:X.current,state:D.getState()})}),[]);let A=_(H,W);return X.current=H,A}let D;WR("createComponent","@effector/reflect"),UO.store(O)?D=O:typeof O=="object"&&O!==null?D=cO(O):KO("shape should be a store or object with stores");let L="Unknown";D&&D.shortName&&(L=D.shortName);let B=d(),Z=d();return E.mounted=B,E.unmounted=Z,j_(`${L}.View`,E)}function UE(O){return WR("createStoreConsumer","useUnit"),p0(O,({children:_},E)=>_(E))}function H0(O,_){let E=_?O:O[0];var D;((Z)=>{if(!Z)throw Error("expect first argument be an object")})(kO(D=E)||((Z)=>typeof Z=="function")(D));let{or:L,and:B}=E;if(B){let Z=_?B:B[0];if(kO(Z)&&"and"in Z){let H=H0(B,_);O=H[0],L={...L,...H[1]}}else O=B}return[O,L]}function c0(O,_){let E=_&&kO(D=_[0])&&(D.and||D.or)?_:[{and:_}];var D;let[[L,B],Z]=H0(E),H,X={},W={},A=Z;var K;return typeof L=="string"?(W={name:L},kO(K=B)&&("sid"in K)||(X=B||{})):((U)=>kO(U)&&(("domain"in U)||("defaultState"in U)||("name"in U)))(L)&&(W=L,X=L.defaultState||{},H=L.domain),{hook:O,domain:H,defaultState:X,mainConfig:W,maybeConfig:A}}function KE(...O){return(({domain:_,defaultState:E,hook:D,mainConfig:L,maybeConfig:B})=>{function Z(M){return D(Z,M,FO()),null}let H=ZR({or:B,and:L}),X=`${_?`${_.compositeName.fullName}/`:""}${H.name||"gate"}`,W=d({name:`${X}.set`,sid:H.sid?`${H.sid}|set`:void 0}),A=d({name:`${X}.open`,sid:H.sid?`${H.sid}|open`:void 0}),K=d({name:`${X}.close`,sid:H.sid?`${H.sid}|close`:void 0}),U=XO(Boolean(0),{name:`${X}.status`,serialize:"ignore"}).on(A,()=>Boolean(1)).on(K,()=>Boolean(0)),Q=XO(E,{name:`${X}.state`,sid:H.sid}).on(W,(M,Y)=>Y).on(A,(M,Y)=>Y).reset(K);if(_){let{hooks:M}=_;HO({target:[M.store,M.store,M.event,M.event,M.event],params:[U,Q,A,K,W]})}return Z.open=A,Z.close=K,Z.status=U,Z.state=Q,Z.set=W,j_(`Gate:${X}`,Z)})(c0(B0,O))}var KO=(O)=>{throw Error(O)},BR=typeof window<"u"?f.default.useLayoutEffect:f.default.useEffect,M0=(O,_,E)=>{f.useEffect(()=>{O&&console.error(`${_} is deprecated${E?`, prefer ${E} instead`:""}`)},[O,_,E])},{useSyncExternalStore:X0}=W0.default,{useSyncExternalStoreWithSelector:i0}=G0.default,GR=(O,_)=>_?_.getState(O):O.getState(),D0=(O,_)=>O!==_,U0=f.default.createContext(null),{Provider:QE}=U0,WR=(O,_)=>{console.error(`${O} is deprecated${_?`, use ${_} instead`:""}`)},AE=(O)=>(WR("connect","useUnit"),(_)=>{let E=O;return typeof O!="function"&&(E=_,_=O),j_(`Connect(${E.displayName||E.name||"Unknown"})`,(D)=>f.default.createElement(E,{...D,...Z0(_)}))}),kO=(O)=>typeof O=="object"&&O!==null,ZR=(O,_={})=>(kO(O)&&(ZR(O.or,_),((E)=>{for(let B in E)L=B,((Z)=>Z===void 0)(D=E[B])||L==="or"||L==="and"||(_[L]=D);var D,L})(O),ZR(O.and,_)),_);export{HE as useUnit,GE as useStoreMap,Z0 as useStore,XE as useProvidedScope,WE as useList,ME as useGate,ZE as useEvent,UE as createStoreConsumer,KE as createGate,p0 as createComponent,AE as connect,QE as Provider};
