// ../../node_modules/.bun/effector@23.4.4/node_modules/effector/effector.mjs
function e(e2, t2) {
  for (const r2 in e2) t2(e2[r2], r2);
}
function t(e2, t2) {
  e2.forEach(t2);
}
function r(e2, t2, r2) {
  if (!e2) throw Error(`${r2 ? r2 + ": " : ""}${t2}`);
}
function n(e2, t2) {
  const r2 = T(e2), n2 = r2.meta || {};
  re(e2) || (n2.isRegion = 1), ye = { id: r2.id, parent: ye, value: e2, template: n2.template || ve(), sidRoot: n2.sidRoot || ye && ye.sidRoot, meta: n2 };
  try {
    return t2();
  } finally {
    be("region"), ye = H(ye);
  }
}
function a({ node: e2 = [], from: r2, source: n2, parent: a2 = r2 || n2, to: o2, target: s2, child: i2 = o2 || s2, scope: c2 = {}, meta: l2 = {}, family: d2 = { type: "regular" }, regional: u2 } = {}) {
  const f2 = $e(a2), p2 = $e(d2.links), m2 = $e(d2.owners), g2 = [];
  t(e2, ((e3) => e3 && ie(g2, e3)));
  const h2 = { id: pe(), seq: g2, next: $e(i2), meta: l2, scope: c2, family: { triggers: f2.length, type: d2.type || "crosslink", links: p2, owners: m2 } };
  return t(p2, ((e3) => ie(V(e3), h2))), t(m2, ((e3) => ie(B(e3), h2))), t(f2, ((e3) => ie(e3.next, h2))), u2 && ye && we(W(ye), [h2]), h2;
}
function o(e2, r2, n2) {
  let a2, o2 = ot, s2 = null, i2 = tt;
  if (e2.target && (r2 = e2.params, n2 = e2.defer, a2 = e2.meta, o2 = "page" in e2 ? e2.page : o2, e2.stack && (s2 = e2.stack), i2 = U(e2) || i2, e2 = e2.target), i2 && tt && i2 !== tt && (tt = null), Array.isArray(e2)) for (let t2 = 0; t2 < e2.length; t2++) Xe("pure", o2, T(e2[t2]), s2, r2[t2], i2, a2);
  else Xe("pure", o2, T(e2), s2, r2, i2, a2);
  if (n2 && !rt) return;
  const c2 = { isRoot: rt, currentPage: ot, scope: tt, isWatch: nt, isPure: at };
  let l2, d2, u2, f2, p2, m2;
  rt = 0;
  e: for (; f2 = Qe(); ) {
    const { idx: e3, stack: r3, type: n3 } = f2;
    u2 = r3.node, ot = p2 = r3.page, tt = U(r3), p2 ? m2 = p2.reg : tt && (m2 = tt.reg);
    const a3 = !!p2, o3 = !!tt, s3 = { fail: 0, scope: u2.scope };
    l2 = d2 = 0;
    for (let t2 = e3; t2 < u2.seq.length && !l2; t2++) {
      const i3 = u2.seq[t2];
      if (i3.order) {
        const { priority: a4, barrierID: o4 } = i3.order, s4 = o4 ? p2 ? `${p2.fullID}_${o4}` : o4 : 0;
        if (t2 !== e3 || n3 !== a4) {
          o4 ? et.has(s4) || (et.add(s4), Ye(t2, r3, a4, o4)) : Ye(t2, r3, a4, 0);
          continue e;
        }
        o4 && et.delete(s4);
      }
      switch (i3.type) {
        case "mov": {
          const e5 = i3.data;
          let t3;
          switch (e5.from) {
            case "stack":
              t3 = W(r3);
              break;
            case "a":
            case "b":
              t3 = r3[e5.from];
              break;
            case "value":
              t3 = e5.store;
              break;
            case "store":
              if (m2 && !m2[e5.store.id]) if (a3) {
                const t4 = lt(p2, e5.store.id);
                r3.page = p2 = t4, t4 ? m2 = t4.reg : o3 ? (mt(tt, e5.store, 0, 1, e5.softRead), m2 = tt.reg) : m2 = void 0;
              } else o3 && mt(tt, e5.store, 0, 1, e5.softRead);
              t3 = We(m2 && m2[e5.store.id] || e5.store);
          }
          switch (e5.to) {
            case "stack":
              r3.value = t3;
              break;
            case "a":
            case "b":
              r3[e5.to] = t3;
              break;
            case "store":
              dt(p2, tt, e5.target, 0).current = t3;
          }
          break;
        }
        case "compute":
          const e4 = i3.data;
          if (e4.fn) {
            nt = "watch" === u2.meta.op, at = e4.pure;
            const t3 = e4.safe ? (0, e4.fn)(W(r3), s3.scope, r3) : gt(s3, e4.fn, r3);
            e4.filter ? d2 = !t3 : r3.value = t3, nt = c2.isWatch, at = c2.isPure;
          }
      }
      l2 = s3.fail || d2;
    }
    if (ut && ut(r3, s3), !l2) {
      const e4 = W(r3), n4 = U(r3);
      if (t(u2.next, ((t2) => {
        Xe("child", p2, t2, r3, e4, n4);
      })), n4) {
        u2.meta.needFxCounter && Xe("child", p2, n4.fxCount, r3, e4, n4), u2.meta.storeChange && Xe("child", p2, n4.storeChange, r3, e4, n4), u2.meta.warnSerialize && Xe("child", p2, n4.warnSerializeNode, r3, e4, n4);
        const a4 = n4.additionalLinks[u2.id];
        a4 && t(a4, ((t2) => {
          Xe("child", p2, t2, r3, e4, n4);
        }));
      }
    }
  }
  rt = c2.isRoot, ot = c2.currentPage, tt = U(c2);
}
function s(t2, r2 = "combine") {
  let n2 = r2 + "(", a2 = "", o2 = 0;
  return e(t2, ((e2) => {
    o2 < 25 && (null != e2 && (n2 += a2, n2 += Q(e2) ? K(e2).fullName : e2.toString()), o2 += 1, a2 = ", ");
  })), n2 + ")";
}
function i(e2, t2) {
  e2.shortName = t2, Object.assign(K(e2), c(t2, H(e2)));
}
function c(e2, t2) {
  let r2, n2;
  const a2 = e2;
  if (t2) {
    const a3 = K(t2);
    0 === e2.length ? (r2 = a3.path, n2 = a3.fullName) : (r2 = a3.path.concat([e2]), n2 = 0 === a3.fullName.length ? e2 : a3.fullName + "/" + e2);
  } else r2 = 0 === e2.length ? [] : [e2], n2 = e2;
  return { shortName: a2, fullName: n2, path: r2 };
}
function l(e2, t2) {
  if (!t2) return e2;
  if (!t2.name && !t2.named && !t2.loc) return e2;
  let r2 = `[${e2}]`;
  const n2 = t2.named || t2.name;
  n2 && (r2 += ` unit '${n2}'`);
  const a2 = t2.loc;
  return !n2 && a2 && (r2 += ` (${a2.file}:${a2.line}:${a2.column})`), r2;
}
function d(e2, t2) {
  const r2 = t2 ? e2 : e2[0];
  Re(r2);
  let n2 = r2.or;
  const a2 = r2.and;
  if (a2) {
    const r3 = t2 ? a2 : a2[0];
    if (Me(r3) && "and" in r3) {
      const r4 = d(a2, t2);
      e2 = r4[0], n2 = { ...n2, ...r4[1] };
    } else e2 = a2;
  }
  return [e2, n2];
}
function u(e2) {
  const t2 = () => e2();
  return t2.unsubscribe = () => e2(), t2;
}
function f(e2, ...t2) {
  const r2 = ve();
  if (r2) {
    const n2 = r2.handlers[e2];
    if (n2) return n2(r2, ...t2);
  }
}
function p(e2, t2) {
  const n2 = ht({ or: t2, and: "string" == typeof e2 ? { name: e2 } : e2 }), s2 = l("event", n2), i2 = (e3, ...t3) => (r(!G(i2, "derived"), "call of derived event is not supported, use createEvent instead", s2), r(!at, "unit call from pure function is not supported, use operators like sample instead", s2), ot ? ((e4, t4, r2, n3) => {
    const a2 = ot;
    let o2 = null;
    if (t4) for (o2 = ot; o2 && o2.template !== t4; ) o2 = H(o2);
    ct(o2);
    const s3 = e4.create(r2, n3);
    return ct(a2), s3;
  })(i2, c2, e3, t3) : i2.create(e3, t3)), c2 = ve(), d2 = Object.assign(i2, { graphite: a({ meta: Ct(n2.actualOp || "event", i2, n2, Nt(p)), regional: 1 }), create: (e3) => (o({ target: i2, params: e3, scope: tt }), e3), watch: (e3) => xt(i2, e3), map: (e3) => jt(i2, P, e3, [Ve()]), filter: (e3) => jt(i2, "filter", e3.fn ? e3 : e3.fn, [Ve(Oe, 1)]), filterMap: (e3) => jt(i2, "filterMap", e3, [Ve(), Pe(((e4) => !ze(e4)), 1)]), prepend(e3) {
    r(i2.targetable, ".prepend of derived event is not supported, call source event instead", s2);
    const t3 = p("* → " + i2.shortName, { parent: H(i2) });
    return f("eventPrepend", T(t3)), $t(t3, i2, [Ve()], "prepend", e3), Rt(i2, t3), t3;
  } });
  return null != n2 && n2.domain && n2.domain.hooks.event(d2), J(d2, "id", d2.graphite.id), be(d2.graphite), d2;
}
function m(e2, n2, a2, o2, s2) {
  return Ne(a2, `${s2} ${n2}`, "first argument"), r(xe(o2), "second argument should be a function", s2), ce(!G(e2, "derived"), `${n2} in derived store`, `${n2} in store created via createStore`, s2), t(Array.isArray(a2) ? a2 : [a2], ((t2) => {
    e2.off(t2), Ot(t2, e2, "on", Ie, o2);
  })), e2;
}
function g(e2, n2) {
  const s2 = ht(n2), i2 = Le(e2), c2 = l("store", s2), d2 = p({ named: "updates", derived: 1 });
  f("storeBase", i2);
  const u2 = i2.id, h2 = "skipVoid" in s2, y2 = h2 && !s2.skipVoid;
  ce(!(h2 && s2.skipVoid), "{skipVoid: true}", "updateFilter", c2);
  const b2 = { updates: d2, defaultState: e2, stateRef: i2, getState() {
    let e3, t2 = i2;
    if (ot) {
      let t3 = ot;
      for (; t3 && !t3.reg[u2]; ) t3 = H(t3);
      t3 && (e3 = t3);
    }
    return !e3 && tt && (mt(tt, i2, 1), e3 = tt), e3 && (t2 = e3.reg[u2]), We(t2);
  }, setState: (e3) => o({ target: b2, params: e3, defer: 1, scope: tt }), reset: (...e3) => (r(b2.targetable, ".reset of derived store is not supported", c2), t(e3, ((e4) => m(b2, ".reset", e4, (() => b2.defaultState), c2))), b2), on: (e3, t2) => (r(b2.targetable, ".on of derived store is not supported", c2), m(b2, ".on", e3, t2, c2)), off(e3) {
    const t2 = T(e3).id, r2 = T(b2).family.links.find(((e4) => e4.meta.onTrigger === t2));
    return r2 && St(r2), b2;
  }, map(e3, t2) {
    let r2, n3;
    Me(e3) && (r2 = e3, e3 = e3.fn);
    const a2 = b2.getState(), o2 = ze(a2);
    ve() ? n3 = null : (!o2 || o2 && y2) && (n3 = e3(a2));
    const s3 = g(n3, { name: `${b2.shortName} → *`, derived: 1, ...t2, and: r2 }), c3 = Ot(b2, s3, P, Oe, e3);
    return He(L(s3), { type: P, fn: e3, from: i2 }), L(s3).noInit = 1, f("storeMap", i2, c3), s3;
  }, watch(e3, t2) {
    if (ce(!t2, "watch second argument", "sample", c2), !t2 || !Q(e3)) {
      const t3 = xt(b2, e3);
      return f("storeWatch", i2, e3) || e3(b2.getState()), t3;
    }
    return r(xe(t2), "second argument should be a function", c2), e3.watch(((e4) => t2(b2.getState(), e4)));
  } }, v2 = Ct("store", b2, s2, Nt(g)), k2 = b2.defaultConfig.updateFilter;
  b2.graphite = a({ scope: { state: i2, fn: k2 }, node: [Pe(((e3, t2, r2) => (r2.scope && !r2.scope.reg[i2.id] && (r2.b = 1), e3))), Te(i2), Pe(((e3, t2, { a: r2, b: n3 }) => {
    const a2 = ze(e3);
    return a2 && !h2 && le(`${It}`, b2.graphite), (a2 && y2 || !a2) && (e3 !== r2 || n3);
  }), 1), k2 && Ve(je, 1), qe({ from: "stack", target: i2 })], child: d2, meta: { ...v2, defaultState: e2, stateRef: i2 }, regional: 1 }), J(b2, "id", b2.graphite.id), J(b2, "rootStateRefId", u2);
  const S2 = G(b2, "serialize"), w2 = G(b2, "derived"), $2 = "ignore" === S2, M2 = G(b2, "sid");
  M2 && (J(b2, "storeChange", 1), i2.sid = M2), M2 || $2 || w2 || J(b2, "warnSerialize", 1);
  const x2 = ze(e2);
  return r(w2 || !x2 || x2 && y2, It, c2), w2 && x2 && !h2 && console.error(`${c2}: ${It}`), we(b2, [d2]), null != s2 && s2.domain && s2.domain.hooks.store(b2), w2 || (b2.reinit = p({ named: "reinit" }), b2.reset(b2.reinit)), i2.meta = b2.graphite.meta, be(b2.graphite), b2;
}
function h(...e2) {
  let t2, n2, a2;
  [e2, a2] = d(e2);
  const o2 = l("combine", a2), s2 = e2[e2.length - 1], i2 = e2.length > 1 && !Y(s2) && Me(s2), c2 = i2 && s2, u2 = i2 ? e2[e2.length - 2] : s2;
  let f2, p2, m2;
  if (xe(u2) ? (n2 = e2.slice(0, i2 ? -2 : -1), t2 = u2) : n2 = e2, 1 === n2.length) {
    const e3 = n2[0];
    Y(e3) || (f2 = e3, p2 = 1);
  }
  if (!p2 && (f2 = n2, t2)) {
    m2 = 1;
    const e3 = t2;
    t2 = (t3) => e3(...t3);
  }
  return r(Me(f2), `${o2}: shape should be an object`), Dt(Array.isArray(f2), !m2, f2, Nt(h), a2, t2, c2);
}
function y() {
  const e2 = {};
  return e2.req = new Promise(((t2, r2) => {
    e2.rs = t2, e2.rj = r2;
  })), e2.req.catch((() => {
  })), e2;
}
function b(e2, t2 = {}) {
  const n2 = ht(xe(e2) ? { handler: e2 } : e2, t2), s2 = l("effect", n2), i2 = p(xe(e2) ? { handler: e2 } : e2, { ...t2, actualOp: "effect" });
  At(i2, Nt(b));
  const c2 = T(i2);
  J(c2, "op", i2.kind = "effect"), i2.use = (e3) => (r(xe(e3), ".use argument should be a function", s2), v2.scope.handler = e3, i2), i2.use.getCurrent = () => v2.scope.handler;
  const d2 = i2.finally = p({ named: "finally", derived: 1 }), u2 = i2.done = d2.filterMap({ named: "done", fn({ status: e3, params: t3, result: r2 }) {
    if ("done" === e3) return { params: t3, result: r2 };
  } }), f2 = i2.fail = d2.filterMap({ named: "fail", fn({ status: e3, params: t3, error: r2 }) {
    if ("fail" === e3) return { params: t3, error: r2 };
  } }), m2 = i2.doneData = u2.map({ named: "doneData", fn: ({ result: e3 }) => e3 }), h2 = i2.failData = f2.map({ named: "failData", fn: ({ error: e3 }) => e3 }), v2 = a({ scope: { handler: i2.defaultConfig.handler || (() => r(0, `no handler used in ${i2.compositeName.fullName}`)) }, node: [Pe(((e3, t3, r2) => {
    let n3 = t3.handler;
    const a2 = U(r2);
    if (a2) {
      const e4 = a2.handlers.unitMap.get(i2) || a2.handlers.sidMap[i2.sid];
      e4 && (n3 = e4);
    }
    return e3.handler = n3, e3;
  }), 0, 1), Pe(((e3, t3, r2) => {
    if (t3.runnerFn && !t3.runnerFn(e3, null, r2)) return;
    const { params: n3, req: a2, handler: o2, args: s3 = [n3] } = e3, i3 = qt(n3, a2, 1, d2, r2), c3 = qt(n3, a2, 0, d2, r2), [l2, u3] = Ft(o2, c3, s3);
    l2 && (Me(u3) && xe(u3.then) ? u3.then(i3, c3) : i3(u3));
  }), 0, 1)], meta: { op: "fx", fx: "runner" }, regional: 1 });
  c2.scope.runner = v2, ie(c2.seq, Pe(((e3, { runner: t3 }, r2) => {
    const n3 = H(r2) ? { params: e3, req: { rs(e4) {
    }, rj(e4) {
    } } } : e3;
    return r2.meta || (r2.meta = { fxID: me() }), o({ target: t3, params: n3, defer: 1, scope: U(r2), meta: r2.meta }), n3.params;
  }))), i2.create = (e3) => {
    const t3 = y(), r2 = { params: e3, req: t3 };
    if (tt && !nt) {
      const e4 = tt;
      t3.req.finally((() => {
        st(e4);
      })).catch((() => {
      }));
    }
    return o({ target: i2, params: r2, scope: tt }), t3.req;
  };
  const k2 = i2.inFlight = g(0, { serialize: "ignore", named: (G(i2, "name") || i2.graphite.id) + ".inFlight" }).on(i2, ((e3) => e3 + 1)).on(d2, ((e3) => e3 - 1)).map({ fn: (e3) => e3, named: "inFlight" });
  J(d2, "needFxCounter", "dec"), J(i2, "needFxCounter", 1);
  const S2 = i2.pending = k2.map({ fn: (e3) => e3 > 0, named: "pending" });
  return we(i2, [d2, u2, f2, m2, h2, S2, k2]), null != n2 && n2.domain && n2.domain.hooks.effect(i2), i2;
}
function v(e2) {
  let t2;
  [e2, t2] = d(e2, 1);
  const n2 = l("attach", t2);
  let { source: a2, effect: s2, mapParams: i2, domain: u2 } = e2;
  ee(s2) && r(ze(u2), "`domain` can only be used with a plain function", n2);
  const f2 = b(e2, t2);
  J(f2, "attached", 1), At(f2, Nt(v));
  const { runner: p2 } = T(f2).scope;
  let m2;
  const g2 = (e3, t3, r2) => {
    const { params: n3, req: s3, handler: c2 } = e3, l2 = f2.finally, d2 = qt(n3, s3, 0, l2, r2), u3 = r2.a, p3 = ee(c2);
    let m3, g3 = 1;
    if (i2 ? [g3, m3] = Ft(i2, d2, [n3, u3]) : m3 = a2 && p3 ? u3 : n3, g3) {
      if (!p3) return e3.args = [u3, m3], 1;
      o({ target: c2, params: { params: m3, req: { rs: qt(n3, s3, 1, l2, r2), rj: d2 } }, page: r2.page, defer: 1, meta: r2.meta });
    }
  };
  if (a2) {
    let e3;
    p2.scope.runnerFn = g2, Y(a2) ? (e3 = a2, we(e3, [f2])) : (e3 = h(a2), we(f2, [e3])), m2 = [Pe(((e4) => e4), 0, 1), Te(L(e3))], delete p2.seq[1].order;
  } else m2 = [Pe(g2, 1, 1)];
  p2.seq.splice(1, 0, ...m2), f2.use(s2);
  const y2 = H(s2);
  return y2 && (Object.assign(K(f2), c(f2.shortName, y2)), f2.defaultConfig.parent = y2), Rt(s2, f2, "effect"), f2;
}
function k(...t2) {
  let [[r2, n2], a2] = d(t2);
  const o2 = {};
  return e(n2, ((e2, t3) => {
    const n3 = o2[t3] = p(t3, { parent: H(r2), config: a2 });
    r2.on(n3, e2), Rt(r2, n3);
  })), o2;
}
function S(r2, n2) {
  const s2 = ht({ or: n2, and: "string" == typeof r2 ? { name: r2 } : r2 }), i2 = a({ family: { type: "domain" }, regional: 1, parent: (null == s2 ? void 0 : s2.domain) || (null == s2 ? void 0 : s2.parent) }), c2 = { history: {}, graphite: i2, hooks: {} };
  i2.meta = Ct("domain", c2, { parent: (null == s2 ? void 0 : s2.domain) || (null == s2 ? void 0 : s2.parent), or: { ...s2, derived: 1 } }, Nt(S)), e({ Event: p, Effect: b, Store: g, Domain: S }, ((e2, r3) => {
    const n3 = r3.toLowerCase(), a2 = p({ named: `on${r3}` });
    c2.hooks[n3] = a2;
    const s3 = /* @__PURE__ */ new Set();
    c2.history[`${n3}s`] = s3, a2.create = (e3) => (o(a2, e3), e3), ie(T(a2).seq, Pe(((e3, t2, r4) => (r4.scope = null, e3)))), a2.watch(((e3) => {
      we(c2, [e3]), s3.add(e3), e3.ownerSet || (e3.ownerSet = s3), H(e3) || (e3.parent = c2);
    })), we(c2, [a2]), c2[`onCreate${r3}`] = (e3) => (t(s3, e3), a2.watch(e3)), c2[`create${r3}`] = c2[n3] = (t2, r4) => {
      const n4 = ht({ and: r4, or: t2 });
      return null != n4 && n4.domain ? e2(t2, r4) : a2(e2(t2, { parent: c2, or: n4 }));
    };
  }));
  const l2 = H(c2);
  return l2 && e(c2.hooks, ((e2, t2) => $t(e2, l2.hooks[t2]))), null != s2 && s2.domain && s2.domain.hooks.domain(c2), c2;
}
function w(e2) {
  Re(e2);
  const t2 = E in e2 ? e2[E]() : e2;
  r(t2.subscribe, "expect observable to have .subscribe");
  const n2 = p(), a2 = wt(n2);
  return t2.subscribe({ next: n2, error: a2, complete: a2 }), n2;
}
function $(e2, n2) {
  let a2 = 0;
  return t(Et, ((t2) => {
    t2 in e2 && (r(null != e2[t2], Pt(n2, t2)), a2 = 1);
  })), a2;
}
function M(...e2) {
  let t2, r2, n2, a2, [[o2, s2, i2], c2] = d(e2), u2 = 1;
  const f2 = l("sample", c2);
  return ze(s2) && Me(o2) && $(o2, f2) && (s2 = o2.clock, i2 = o2.fn, "batch" in o2 ? u2 = o2.batch : (ce(!("greedy" in o2), "greedy in sample", "batch", f2), u2 = !o2.greedy), a2 = o2.filter, t2 = o2.target, r2 = o2.name, n2 = o2.sid, o2 = o2.source), Tt("sample", s2, o2, a2, t2, i2, r2, c2, u2, 1, 0, n2);
}
function x(...e2) {
  let [[t2, r2], n2] = d(e2);
  const a2 = l("guard", n2);
  return ce(0, "guard", "sample", a2), r2 || (r2 = t2, t2 = r2.source), $(r2, a2), Tt("guard", r2.clock, t2, r2.filter, r2.target, null, r2.name, n2, !r2.greedy, 0, 1);
}
function z(e2, t2) {
  const r2 = l("merge", t2);
  Ne(e2, r2, "first argument");
  const n2 = p({ name: s(e2, "merge"), derived: 1, and: t2 });
  return $t(e2, n2, [], "merge"), n2;
}
function R(t2, n2, a2) {
  const o2 = l("restore", a2);
  if (r(!Y(t2), "restore($store) is not supported", o2), Z(t2) || ee(t2)) {
    const e2 = H(t2), r2 = g(n2, { parent: e2, name: t2.shortName, and: a2 });
    return $t(ee(t2) ? t2.doneData : t2, r2), e2 && e2.hooks.store(r2), r2;
  }
  const s2 = Array.isArray(t2) ? [] : {};
  return e(t2, ((e2, t3) => s2[t3] = Y(e2) ? e2 : g(e2, { name: t3 }))), s2;
}
function A(...t2) {
  const n2 = "split";
  let o2, s2, [[i2, c2], u2] = d(t2);
  const m2 = l(n2, u2), g2 = !c2;
  g2 && (o2 = i2.cases, c2 = i2.match, s2 = i2.clock, i2 = i2.source);
  const h2 = Y(c2), y2 = !Q(c2) && xe(c2), b2 = !h2 && !y2 && Me(c2);
  r(Q(i2), "source must be a unit", m2), o2 || (o2 = {}), g2 ? e(o2, ((e2, t3) => Ce(m2, e2, `cases.${t3}`))) : (r(b2, "match should be an object", m2), e(c2, ((e2, t3) => o2[t3] = p({ derived: 1, named: `cases.${t3}`, and: u2 }))), o2.__ = p({ derived: 1, named: "cases.__", and: u2 }));
  const v2 = new Set([].concat(i2, s2 || [], Object.values(o2))), k2 = Object.keys(h2 || y2 ? o2 : c2);
  let S2, w2;
  if (h2 || y2) h2 && v2.add(c2), S2 = [h2 && Te(L(c2), 0, 1), _e({ safe: h2, filter: 1, pure: !h2, fn(e2, t3, r2) {
    const n3 = String(h2 ? r2.a : c2(e2));
    Lt(t3, oe(k2, n3) ? n3 : "__", e2, r2);
  } })];
  else if (b2) {
    const t3 = w2 = Le({});
    t3.type = "shape";
    const r2 = [];
    let n3;
    e(c2, ((e2, a2) => {
      if (Q(e2)) {
        n3 = 1, ie(r2, a2), v2.add(e2);
        const o3 = $t(e2, [], [Te(t3), Pe(((e3, t4, { a: r3 }) => r3[a2] = e3))]);
        if (Y(e2)) {
          t3.current[a2] = e2.getState();
          const r3 = L(e2);
          He(t3, { from: r3, field: a2, type: "field" }), f("splitMatchStore", r3, o3);
        }
      }
    })), n3 && f("splitBase", t3), S2 = [n3 && Te(t3, 0, 1), Ve(((e2, t4, n4) => {
      for (let a2 = 0; a2 < k2.length; a2++) {
        const o3 = k2[a2];
        if (oe(r2, o3) ? n4.a[o3] : c2[o3](e2)) return void Lt(t4, o3, e2, n4);
      }
      Lt(t4, "__", e2, n4);
    }), 1)];
  } else r(0, "expect match to be unit, function or object");
  const $2 = a({ meta: { op: n2, stateRef: w2 }, parent: s2 ? [] : i2, scope: o2, node: S2, family: { owners: Array.from(v2) }, regional: 1 });
  if (s2 && Tt(n2, s2, i2, null, $2, null, n2, u2, 0, 0, 0), At($2, Nt(A)), !g2) return o2;
}
function N(e2, { scope: t2, params: r2 } = {}) {
  if (!Q(e2)) return Promise.reject(new Error("first argument should be unit"));
  if (!(ee(e2) || Z(e2) || Y(e2) || ne(e2))) return Promise.reject(new Error("first argument accepts only effects, events, stores or scopes"));
  if (ne(e2)) t2 = e2;
  else if (!te(e2)) {
    const t3 = l("allSettled", T(e2).meta);
    return Promise.reject(Error(`${t3}: unit should be targetable`));
  }
  const n2 = y();
  n2.parentFork = tt;
  const { fxCount: a2 } = t2;
  ie(a2.scope.defers, n2);
  const s2 = [], i2 = [];
  return ne(e2) || (ie(s2, e2), ie(i2, ee(e2) ? { params: r2, req: { rs(e3) {
    n2.value = { status: "done", value: e3 };
  }, rj(e3) {
    n2.value = { status: "fail", value: e3 };
  } } } : r2)), ie(s2, a2), ie(i2, null), o({ target: s2, params: i2, scope: t2 }), n2.req;
}
function C(e2, r2, n2) {
  const a2 = [];
  (function e3(o2) {
    oe(a2, o2) || (ie(a2, o2), "store" === G(o2, "op") && (n2 || G(o2, "sid")) && r2(o2, G(o2, "sid")), t(o2.next, e3), t(V(o2), e3), t(B(o2), e3));
  })(e2);
}
function j(e2, n2) {
  const a2 = Array.isArray(e2) ? new Map(e2) : e2, o2 = /* @__PURE__ */ new Map();
  let s2 = 0;
  if (a2 instanceof Map) {
    const e3 = {};
    return t(a2, ((t2, a3) => {
      r(Q(a3), "Map key should be a unit"), n2 && n2(a3, t2), a3.sid && (a3.sid in e3 && (s2 = 1), e3[a3.sid] = t2), o2.set(a3, t2);
    })), { sidMap: e3, unitMap: o2, hasSidDoubles: s2 };
  }
  return { sidMap: a2, unitMap: o2 };
}
function I(e2, n2) {
  let o2, s2 = e2;
  re(e2) && (ce(0, "fork(domain)", "fork()"), o2 = e2, s2 = n2);
  const i2 = ((e3) => {
    const r2 = a({ scope: { defers: [], inFlight: 0, fxID: 0 }, node: [Pe(((e4, t2, r3) => {
      r3.parent ? "dec" === r3.parent.node.meta.needFxCounter ? t2.inFlight -= 1 : (t2.inFlight += 1, t2.fxID += 1) : t2.fxID += 1;
    })), _e({ priority: "sampler", batch: 1 }), Pe(((e4, r3) => {
      const { defers: n4, fxID: a2 } = r3;
      r3.inFlight > 0 || 0 === n4.length || Promise.resolve().then((() => {
        r3.fxID === a2 && t(n4.splice(0, n4.length), ((e5) => {
          st(e5.parentFork), e5.rs(e5.value);
        }));
      }));
    }), 0, 1)] }), n3 = a({ node: [Pe(((e4, t2, r3) => {
      const n4 = r3.parent;
      if (n4) {
        const t3 = n4.node;
        if (Ht(n4)) {
          const n5 = U(r3), a2 = t3.meta.sid;
          n5.sidIdMap[a2] = t3.scope.state.id, n5.values.sidMap[a2] = e4;
          const o4 = t3.meta.serialize;
          o4 && n5.sidSerializeSettings.set(a2, "ignore" === o4 ? { ignore: 1 } : { ignore: 0, write: o4.write });
        }
      }
    }))] }), o3 = a({ node: [Pe(((e4, t2, r3) => {
      const n4 = U(r3), a2 = r3.parent;
      n4 && a2 && Ht(a2) && n4.warnSerializeNodes.add(a2.node);
    }))] }), s3 = { cloneOf: e3, reg: {}, values: { sidMap: {}, idMap: {} }, sidIdMap: {}, sidSerializeSettings: /* @__PURE__ */ new Map(), getState(e4) {
      if ("current" in e4) return dt(ot, s3, e4, 0).current;
      const t2 = T(e4);
      return dt(ot, s3, t2.scope.state, 1).current;
    }, kind: "scope", graphite: a({ family: { type: "domain", links: [r2, n3, o3] }, meta: { unit: "fork" }, scope: { forkInFlightCounter: r2 } }), additionalLinks: {}, handlers: { sidMap: {}, unitMap: /* @__PURE__ */ new Map() }, fxCount: r2, storeChange: n3, warnSerializeNodes: /* @__PURE__ */ new Set(), warnSerializeNode: o3 };
    return s3;
  })(o2);
  if (s2) {
    if (s2.values) {
      const { sidMap: e3, unitMap: n3, hasSidDoubles: a2 } = j(s2.values, ((e4) => r(Y(e4) && te(e4), "Values map can contain only writable stores as keys")));
      Object.assign(i2.values.sidMap, e3), t(n3, ((e4, t2) => {
        if (i2.values.idMap[t2.stateRef.id] = e4, i2.sidIdMap[G(t2, "sid")] = t2.stateRef.id, "ignore" === G(t2, "serialize")) {
          const e5 = G(t2, "sid");
          i2.sidSerializeSettings.set(e5, { ignore: 1 });
        }
      })), i2.fromSerialize = !(Array.isArray(s2.values) || s2.values instanceof Map), i2.hasSidDoubles = a2;
    }
    s2.handlers && (ce(s2.handlers instanceof Map || Array.isArray(s2.handlers), "object with handlers", "array"), i2.handlers = j(s2.handlers, ((e3) => r(ee(e3), "Handlers map can contain only effects as keys"))));
  }
  return i2;
}
function O(e2, { values: n2 }) {
  r(Me(n2), "values property should be an object");
  const { sidMap: a2, unitMap: s2 } = j(n2), i2 = Object.getOwnPropertyNames(a2), c2 = {};
  t(s2, ((e3, t2) => {
    c2[t2.stateRef.id] = t2;
  }));
  const l2 = [], d2 = [];
  let u2, f2, p2;
  ne(e2) ? (u2 = e2, p2 = 1, r(u2.cloneOf, "scope should be created from domain"), ce(0, "hydrate(fork(domain), { values })", "fork({ values })"), f2 = T(u2.cloneOf)) : re(e2) ? (ce(0, "hydrate(domain, { values })", "fork({ values })"), f2 = T(e2)) : r(0, "first argument of hydrate should be domain or scope"), C(f2, ((e3, t2) => {
    if (t2 && oe(i2, t2)) {
      ie(l2, e3);
      const r2 = G(e3, "serialize");
      r2 && "ignore" !== r2 && (a2[t2] = r2.read(a2[t2])), ie(d2, a2[t2]);
    } else e3.scope.state.id in c2 && (ie(l2, e3), ie(d2, s2.get(c2[e3.scope.state.id])));
  }), 1), o({ target: l2, params: d2, scope: u2 }), p2 && Object.assign(u2.values.sidMap, a2);
}
function D(e2, { scope: t2, safe: n2 } = {}) {
  r(t2 || tt || n2, "scopeBind: scope not found");
  const a2 = t2 || tt;
  return (...t3) => {
    function r2() {
      st(s2);
    }
    let n3, o2 = 0;
    const s2 = tt;
    st(a2);
    try {
      n3 = e2(...t3);
    } catch (e3) {
      n3 = e3, o2 = 1;
    }
    if (r2(), o2) throw n3;
    return n3 instanceof Promise && n3.then(r2, r2), n3;
  };
}
function F(n2, a2 = {}) {
  n2.warnSerializeNodes.size && (console.error("serialize: One or more stores dont have sids, their values are omitted"), t(n2.warnSerializeNodes, ((e2) => {
    le("store should have sid or `serialize: ignore`", e2);
  }))), r(!n2.hasSidDoubles, "duplicate sid found in this scope");
  const o2 = a2.ignore ? a2.ignore.map((({ sid: e2 }) => e2)) : [], s2 = {};
  return e(n2.values.sidMap, ((e2, t2) => {
    var r2;
    if (oe(o2, t2)) return;
    const a3 = n2.sidIdMap[t2], i2 = null !== (r2 = n2.sidSerializeSettings.get(t2)) && void 0 !== r2 ? r2 : { ignore: 0, write: Ut };
    i2.ignore || (s2[t2] = (0, i2.write)(a3 && a3 in n2.reg ? n2.reg[a3].current : e2));
  })), "onlyChanges" in a2 && (ce(0, "onlyChanges"), a2.onlyChanges || (r(n2.cloneOf, "scope should be created from domain"), C(T(n2.cloneOf), ((e2, t2) => {
    t2 in s2 || oe(o2, t2) || G(e2, "isCombine") || "ignore" === G(e2, "serialize") || (s2[t2] = n2.getState(e2));
  })))), s2;
}
function q({ unit: e2, fn: t2, scope: r2, batch: n2 }) {
  const o2 = [Be.run({ fn: (e3) => t2(e3) })];
  n2 && o2.unshift(Be.compute({ priority: "sampler", batch: 1 })), Y(e2) && o2.unshift(Be.mov({ store: e2.stateRef, to: "stack" }));
  const s2 = Array.isArray(e2) ? e2 : [e2];
  if (r2) {
    const e3 = [], t3 = r2.additionalLinks;
    return s2.forEach(((r3) => {
      const n3 = t3[r3.graphite.id] || [];
      t3[r3.graphite.id] = n3;
      const s3 = a({ node: _(o2, r3), meta: { watchOp: r3.kind } });
      n3.push(s3), e3.push((() => {
        const e4 = n3.indexOf(s3);
        -1 !== e4 && n3.splice(e4, 1), St(s3);
      }));
    })), u((() => {
      e3.forEach(((e4) => e4()));
    }));
  }
  {
    const e3 = a({ node: o2, parent: s2, family: { owners: s2 } });
    return u((() => {
      St(e3);
    }));
  }
}
function _(e2, t2) {
  return Y(t2) ? [Be.mov({ store: t2.stateRef, to: "stack" }), ...e2] : e2;
}
var E = "undefined" != typeof Symbol && Symbol.observable || "@@observable";
var P = "map";
var T = (e2) => e2.graphite || e2;
var V = (e2) => e2.family.owners;
var B = (e2) => e2.family.links;
var L = (e2) => e2.stateRef;
var W = (e2) => e2.value;
var H = (e2) => e2.parent;
var U = (e2) => e2.scope;
var G = (e2, t2) => T(e2).meta[t2];
var J = (e2, t2, r2) => T(e2).meta[t2] = r2;
var K = (e2) => e2.compositeName;
var Q = (e2) => (xe(e2) || Me(e2)) && "kind" in e2;
var X = (e2) => (t2) => Q(t2) && t2.kind === e2;
var Y = X("store");
var Z = X("event");
var ee = X("effect");
var te = (e2) => Q(e2) && !!e2.targetable;
var re = X("domain");
var ne = X("scope");
var ae = { __proto__: null, unit: Q, store: Y, event: Z, effect: ee, targetable: te, domain: re, scope: ne, attached: (e2) => ee(e2) && 1 == G(e2, "attached") };
var oe = (e2, t2) => e2.includes(t2);
var se = (e2, t2) => {
  const r2 = e2.indexOf(t2);
  -1 !== r2 && e2.splice(r2, 1);
};
var ie = (e2, t2) => e2.push(t2);
var ce = (e2, t2, r2, n2) => !e2 && console.error(`${n2 ? n2 + ": " : ""}${t2} is deprecated${r2 ? `, use ${r2} instead` : ""}`);
var le = (e2, t2) => {
  const r2 = G(t2, "unitTrace"), n2 = G(t2, "config"), a2 = null != n2 && n2.loc ? ` at ${n2.loc.file}` : null, o2 = null == n2 ? void 0 : n2.name;
  let s2 = e2;
  o2 && (s2 = `${o2}: ${e2}`), a2 && (s2 = `${o2}${a2}: ${e2}`);
  const i2 = Error(s2);
  r2 && (i2.stack = r2), r2 || o2 || a2 || console.log(`Add effector's Babel or SWC plugin to your config for more detailed debug information or "import "effector/enable_debug_traces" to your code entry module to see full stack traces`), console.error(i2);
};
var de = () => {
  let e2 = 0;
  return () => "" + ++e2;
};
var ue = de();
var fe = de();
var pe = de();
var me = de();
var ge;
var he = (e2) => {
  ge = e2;
};
var ye = null;
var be = (e2) => {
  ge && ge(e2, ye);
};
var ve = () => ye && ye.template;
var ke = (e2) => (e2 && ye && ye.sidRoot && (e2 = `${ye.sidRoot}|${e2}`), e2);
var Se = ({ sid: e2, name: t2, loc: r2, method: o2, fn: s2 }) => n(a({ meta: { sidRoot: ke(e2), sid: e2, name: t2, loc: r2, method: o2, type: "factory" }, regional: 1 }), s2);
var we = (e2, r2) => {
  const n2 = T(e2);
  t(r2, ((e3) => {
    const t2 = T(e3);
    "domain" !== n2.family.type && (t2.family.type = "crosslink"), ie(V(t2), n2), ie(B(n2), t2);
  }));
};
var $e = (e2 = []) => (Array.isArray(e2) ? e2 : [e2]).flat().map(T);
var Me = (e2) => "object" == typeof e2 && null !== e2;
var xe = (e2) => "function" == typeof e2;
var ze = (e2) => void 0 === e2;
var Re = (e2) => r(Me(e2) || xe(e2), "expect first argument be an object");
var Ae = (e2, t2, n2, a2) => r(!(!Me(e2) && !xe(e2) || !("family" in e2) && !("graphite" in e2)), `${t2}: expect ${n2} to be a unit (store, event or effect)${a2}`);
var Ne = (e2, r2, n2) => {
  Array.isArray(e2) ? t(e2, ((e3, t2) => Ae(e3, r2, `${t2} item of ${n2}`, ""))) : Ae(e2, r2, n2, " or array of units");
};
var Ce = (e2, n2, a2 = "target") => t($e(n2), ((t2) => r(!G(t2, "derived"), `${e2}: derived unit in "${a2}" is not supported, use createStore/createEvent instead"`)));
var je = (e2, { fn: t2 }, { a: r2 }) => t2(e2, r2);
var Ie = (e2, { fn: t2 }, { a: r2 }) => t2(r2, e2);
var Oe = (e2, { fn: t2 }) => t2(e2);
var De = (e2, t2, r2, n2) => {
  const a2 = { id: fe(), type: e2, data: t2 };
  return r2 && (a2.order = { priority: r2 }, n2 && (a2.order.barrierID = ++Fe)), a2;
};
var Fe = 0;
var qe = ({ from: e2 = "store", store: t2, target: r2, to: n2 = r2 ? "store" : "stack", batch: a2, priority: o2 }) => De("mov", { from: e2, store: t2, to: n2, target: r2 }, o2, a2);
var _e = ({ fn: e2, batch: t2, priority: r2, safe: n2 = 0, filter: a2 = 0, pure: o2 = 0 }) => De("compute", { fn: e2, safe: n2, filter: a2, pure: o2 }, r2, t2);
var Ee = ({ fn: e2 }) => _e({ fn: e2, priority: "effect" });
var Pe = (e2, t2, r2) => _e({ fn: e2, safe: 1, filter: t2, priority: r2 && "effect" });
var Te = (e2, t2, r2) => qe({ store: e2, to: t2 ? "stack" : "a", priority: r2 && "sampler", batch: 1 });
var Ve = (e2 = Oe, t2) => _e({ fn: e2, pure: 1, filter: t2 });
var Be = { mov: qe, compute: _e, filter: ({ fn: e2, pure: t2 }) => _e({ fn: e2, filter: 1, pure: t2 }), run: Ee };
var Le = (e2) => ({ id: fe(), current: e2, initial: e2 });
var We = ({ current: e2 }) => e2;
var He = (e2, t2) => {
  e2.before || (e2.before = []), ie(e2.before, t2);
};
var Ue = null;
var Ge = (e2, t2) => {
  if (!e2) return t2;
  if (!t2) return e2;
  let r2;
  return (e2.v.type === t2.v.type && e2.v.id > t2.v.id || Ze(e2.v.type) > Ze(t2.v.type)) && (r2 = e2, e2 = t2, t2 = r2), r2 = Ge(e2.r, t2), e2.r = e2.l, e2.l = r2, e2;
};
var Je = [];
var Ke = 0;
for (; Ke < 6; ) ie(Je, { first: null, last: null, size: 0 }), Ke += 1;
var Qe = () => {
  for (let e2 = 0; e2 < 6; e2++) {
    const t2 = Je[e2];
    if (t2.size > 0) {
      if (3 === e2 || 4 === e2) {
        t2.size -= 1;
        const e3 = Ue.v;
        return Ue = Ge(Ue.l, Ue.r), e3;
      }
      1 === t2.size && (t2.last = null);
      const r2 = t2.first;
      return t2.first = r2.r, t2.size -= 1, r2.v;
    }
  }
};
var Xe = (e2, t2, r2, n2, a2, o2, s2) => Ye(0, { a: null, b: null, node: r2, parent: n2, value: a2, page: t2, scope: o2, meta: s2 }, e2, 0);
var Ye = (e2, t2, r2, n2) => {
  const a2 = Ze(r2), o2 = Je[a2], s2 = { v: { idx: e2, stack: t2, type: r2, id: n2 }, l: null, r: null };
  3 === a2 || 4 === a2 ? Ue = Ge(Ue, s2) : (0 === o2.size ? o2.first = s2 : o2.last.r = s2, o2.last = s2), o2.size += 1;
};
var Ze = (e2) => {
  switch (e2) {
    case "child":
      return 0;
    case "pure":
      return 1;
    case "read":
      return 2;
    case "barrier":
      return 3;
    case "sampler":
      return 4;
    case "effect":
      return 5;
    default:
      return -1;
  }
};
var et = /* @__PURE__ */ new Set();
var tt;
var rt = 1;
var nt = 0;
var at = 0;
var ot = null;
var st = (e2) => {
  tt = e2;
};
var ct = (e2) => {
  ot = e2;
};
var lt = (e2, t2) => {
  if (e2) {
    for (; e2 && !e2.reg[t2]; ) e2 = e2.parent;
    if (e2) return e2;
  }
  return null;
};
var dt = (e2, t2, r2, n2) => {
  const a2 = lt(e2, r2.id);
  return a2 ? a2.reg[r2.id] : t2 ? (mt(t2, r2, n2), t2.reg[r2.id]) : r2;
};
var ut;
var ft = (e2) => {
  ut = e2;
};
var pt = (e2) => e2;
var mt = (e2, r2, n2, a2, o2) => {
  const s2 = e2.reg;
  if (s2[r2.id]) return;
  const i2 = r2.sid, c2 = { id: r2.id, current: r2.initial, meta: r2.meta };
  if (c2.id in e2.values.idMap) c2.current = e2.values.idMap[c2.id];
  else if (i2 && i2 in e2.values.sidMap && !(i2 in e2.sidIdMap)) {
    var l2;
    const t2 = null == r2 || null === (l2 = r2.meta) || void 0 === l2 ? void 0 : l2.serialize;
    c2.current = (e2.fromSerialize && "ignore" !== t2 && (null == t2 ? void 0 : t2.read) || pt)(e2.values.sidMap[i2]);
  } else if (r2.before && !o2) {
    let o3 = 0;
    const i3 = n2 || !r2.noInit || a2;
    t(r2.before, ((t2) => {
      switch (t2.type) {
        case "map": {
          const r3 = t2.from;
          if ((r3 || t2.fn) && (r3 && mt(e2, r3, n2, a2), i3)) {
            const e3 = r3 && s2[r3.id].current;
            c2.current = t2.fn ? t2.fn(e3) : e3;
          }
          break;
        }
        case "field":
          mt(e2, t2.from, n2, a2), o3 || (o3 = 1, c2.current = Array.isArray(c2.current) ? [...c2.current] : { ...c2.current }), i3 && (c2.current[t2.field] = s2[s2[t2.from.id].id].current);
      }
    }));
  }
  i2 && (e2.sidIdMap[i2] = r2.id), s2[r2.id] = c2;
};
var gt = (e2, t2, r2) => {
  try {
    return t2(W(r2), e2.scope, r2);
  } catch (t3) {
    console.error(t3), e2.fail = 1, e2.failReason = t3;
  }
};
var ht = (t2, r2 = {}) => (Me(t2) && (ht(t2.or, r2), e(t2, ((e2, t3) => {
  ze(e2) || "or" === t3 || "and" === t3 || (r2[t3] = e2);
})), ht(t2.and, r2)), r2);
var yt = (e2, t2) => {
  se(e2.next, t2), se(V(e2), t2), se(B(e2), t2);
};
var bt = ["on", "reset", "sample", "split", "merge", "guard", "forward"];
var vt = (e2, t2, r2, n2, a2) => {
  let o2;
  e2.next.length = 0, e2.seq.length = 0, e2.scope = null;
  let s2 = B(e2);
  const { stateRef: i2, defaultShape: c2, isRegion: l2, op: d2 } = e2.meta;
  if (i2 && (i2.before = [], e2.meta.stateRef = null), c2) for (const e3 in c2) c2[e3] = null;
  const u2 = l2 ? e2 : n2;
  if (s2.length > 0) {
    const n3 = oe(bt, d2), i3 = !l2 && !a2, c3 = i3 && r2 && !n3;
    for (; o2 = s2.pop(); ) {
      const s3 = oe(o2.next, e2);
      yt(o2, e2), l2 && vt(o2, 0, 0, e2, 1), s3 || (o2.family.triggers -= 1), (t2 || c3 || i3 && "crosslink" === o2.family.type && !n3 || a2 && oe(bt, o2.meta.op) && (s3 && 0 === o2.next.length || !s3 && o2.family.triggers <= 0)) && vt(o2, t2, r2 && "on" !== o2.meta.op, u2, a2);
    }
  }
  for (s2 = V(e2); o2 = s2.pop(); ) yt(o2, e2), r2 && "crosslink" === o2.family.type && vt(o2, t2, "on" !== o2.meta.op, u2, a2);
};
var kt = (e2) => e2.clear();
var St = (e2, { deep: t2 } = {}) => {
  let r2 = 0;
  if (e2.ownerSet && e2.ownerSet.delete(e2), re(e2)) {
    r2 = 1;
    const t3 = e2.history;
    kt(t3.events), kt(t3.effects), kt(t3.stores), kt(t3.domains);
  }
  vt(T(e2), !!t2, r2, null, 0);
};
var wt = (e2) => u((() => St(e2)));
var $t = (e2, t2, r2, n2, o2) => a({ node: r2, parent: e2, child: t2, scope: { fn: o2 }, meta: { op: n2 }, family: { owners: [e2, t2], links: t2 }, regional: 1 });
var Mt = (e2) => {
  const t2 = "forward", [{ from: r2, to: n2 }, o2] = d(e2, 1), s2 = l(t2, o2);
  return ce(0, t2, "sample", s2), Ne(r2, s2, '"from"'), Ne(n2, s2, '"to"'), Ce(s2, n2, "to"), wt(a({ parent: r2, child: n2, meta: { op: t2, config: o2 }, family: {}, regional: 1 }));
};
var xt = (e2, t2) => (r(xe(t2), ".watch argument should be a function"), wt(a({ scope: { fn: t2 }, node: [Ee({ fn: Oe })], parent: e2, meta: { op: "watch" }, family: { owners: e2 }, regional: 1 })));
var zt = 0;
var Rt = (e2, t2, r2 = "event") => {
  H(e2) && H(e2).hooks[r2](t2);
};
var At = (e2, t2) => J(e2, "unitTrace", t2);
var Nt = (e2) => {
  if (!zt) return "";
  const t2 = Error("unit trace");
  return Error.captureStackTrace && Error.captureStackTrace(t2, e2), t2.stack;
};
var Ct = (e2, t2, r2, n2) => {
  const a2 = ht(r2), o2 = "domain" === e2, s2 = ue(), { sid: i2 = null, named: l2 = null, domain: d2 = null, parent: u2 = d2 } = a2, f2 = l2 || a2.name || (o2 ? "" : s2), p2 = c(f2, u2), m2 = { op: t2.kind = e2, name: t2.shortName = f2, sid: t2.sid = ke(i2), named: l2, unitId: t2.id = s2, serialize: a2.serialize, derived: a2.derived, config: a2, unitTrace: n2 };
  if (t2.targetable = !a2.derived, t2.parent = u2, t2.compositeName = p2, t2.defaultConfig = a2, t2.getType = () => (ce(0, "getType", "compositeName.fullName"), p2.fullName), !o2) {
    t2.subscribe = (e4) => (Re(e4), t2.watch(xe(e4) ? e4 : (t3) => e4.next && e4.next(t3))), t2[E] = () => t2;
    const e3 = ve();
    e3 && (m2.nativeTemplate = e3);
  }
  return m2;
};
var jt = (e2, t2, r2, n2) => {
  let a2;
  Me(r2) && (a2 = r2, r2 = r2.fn);
  const o2 = p({ name: `${e2.shortName} → *`, derived: 1, and: a2 });
  return $t(e2, o2, n2, t2, r2), o2;
};
var It = "undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option";
var Ot = (e2, t2, r2, n2, a2) => {
  const o2 = L(t2), s2 = qe({ store: o2, to: "a", priority: "read" });
  r2 === P && (s2.data.softRead = 1);
  const i2 = [s2, Ve(n2)];
  f("storeOnMap", o2, i2, Y(e2) && L(e2));
  const c2 = $t(e2, t2, i2, r2, a2);
  return r2 !== P && J(c2, "onTrigger", T(e2).id), c2;
};
var Dt = (t2, n2, o2, i2, c2, d2, u2) => {
  const p2 = l("combine", c2), m2 = t2 ? (e2) => [...e2] : (e2) => ({ ...e2 }), h2 = t2 ? [] : {}, y2 = m2(h2), b2 = Le(y2), v2 = Le(1);
  b2.type = t2 ? "list" : "shape", b2.noInit = 1, f("combineBase", b2, v2);
  const k2 = g(y2, { name: s(o2), derived: 1, ...u2, and: c2 });
  At(k2, i2);
  const S2 = L(k2);
  S2.noInit = 1, J(k2, "isCombine", 1), we(k2, [a({ meta: { stateRef: b2 } })]);
  const w2 = Te(b2);
  w2.order = { priority: "barrier" };
  const $2 = qe({ store: S2, to: "b", priority: "read" });
  $2.data.softRead = 1;
  const M2 = [Pe(((e2, t3, r2) => (r2.scope && !r2.scope.reg[b2.id] && (r2.c = 1), e2))), w2, qe({ store: v2, to: "b" }), Pe(((e2, { key: t3 }, r2) => {
    if (r2.c || e2 !== r2.a[t3]) return n2 && r2.b && (r2.a = m2(r2.a)), r2.a[t3] = e2, 1;
  }), 1), qe({ from: "a", target: b2 }), qe({ from: "value", store: 0, target: v2 }), qe({ from: "value", store: 1, target: v2, priority: "barrier", batch: 1 }), Te(b2, 1, 1), d2 && Ve(), $2];
  if (e(o2, ((e2, t3) => {
    if (!Y(e2)) return r(!Q(e2) && !ze(e2), `combine expects a store in a field ${t3}`, p2), void (y2[t3] = h2[t3] = e2);
    h2[t3] = e2.defaultState, y2[t3] = e2.getState();
    const n3 = $t(e2, k2, M2, "combine", d2);
    n3.scope.key = t3;
    const a2 = L(e2);
    He(b2, { type: "field", field: t3, from: a2 }), f("combineField", a2, n3);
  })), k2.defaultShape = o2, J(k2, "defaultShape", o2), He(S2, { type: P, from: b2, fn: d2 }), !ve()) if (d2) {
    const e2 = d2(y2);
    !ze(e2) || u2 && "skipVoid" in u2 || console.error(`${p2}: ${It}`), S2.current = e2, S2.initial = e2, k2.defaultState = e2;
  } else k2.defaultState = h2;
  return k2;
};
var Ft = (e2, t2, r2) => {
  try {
    return [1, e2(...r2)];
  } catch (e3) {
    return t2(e3), [0, null];
  }
};
var qt = (e2, t2, r2, n2, a2) => (s2) => {
  o({ target: [n2, _t], params: [r2 ? { status: "done", params: e2, result: s2 } : { status: "fail", params: e2, error: s2 }, { value: s2, fn: r2 ? t2.rs : t2.rj }], defer: 1, page: a2.page, scope: a2.scope, meta: a2.meta });
};
var _t = a({ node: [Ee({ fn: ({ fn: e2, value: t2 }) => e2(t2) })], meta: { op: "fx", fx: "sidechain" } });
var Et = ["source", "clock", "target"];
var Pt = (e2, t2) => e2 + `: ${t2} should be defined`;
var Tt = (e2, t2, n2, a2, o2, s2, i2, c2, d2, u2, m2, y2) => {
  const b2 = l(e2, c2), v2 = !!o2;
  r(!ze(n2) || !ze(t2), Pt(b2, "either source or clock"));
  let k2 = 0;
  ze(n2) ? k2 = 1 : Q(n2) || (n2 = h(n2)), ze(t2) ? t2 = n2 : (Ne(t2, b2, "clock"), Array.isArray(t2) && (t2 = $t(t2, [], [], e2))), k2 && (n2 = t2), c2 || i2 ? c2 && i2 ? c2.name = i2 : !c2 && i2 && (c2 = { name: i2 }) : i2 = n2.shortName;
  let S2 = "none";
  (m2 || a2) && (Q(a2) ? S2 = "unit" : (r(xe(a2), "`filter` should be function or unit"), S2 = "fn")), o2 ? (Ne(o2, b2, "target"), Ce(b2, o2)) : "none" === S2 && u2 && Y(n2) && Y(t2) ? o2 = g(s2 ? s2(We(L(n2)), We(L(t2))) : We(L(n2)), { name: i2, sid: y2, or: c2 }) : (o2 = p({ name: i2, derived: 1, or: c2 }), f("sampleTarget", T(o2)));
  const w2 = Le();
  let $2 = [];
  const x2 = [];
  if ("unit" === S2) {
    const [r2, n3, s3, i3] = Bt(a2, o2, t2, w2, e2);
    i3 && ie(x2, i3), s3 || $2.push(...Vt(n3)), $2.push(...Vt(r2));
  }
  const z2 = [];
  if (k2) d2 && ie(z2, Te(w2, 1, 1));
  else {
    const [r2, a3, s3, i3] = Bt(n2, o2, t2, w2, e2);
    i3 && ie(x2, i3), s3 || z2.push(...Vt(a3)), ie(z2, Te(r2, 1, d2));
  }
  const R2 = $t(t2, o2, [f("sampleSourceLoader"), qe({ from: "stack", target: w2 }), ...z2, ...$2, Te(w2), "fn" === S2 && Ve(((e3, t3, { a: r2 }) => a2(e3, r2)), 1), s2 && Ve(je), f("sampleSourceUpward", v2)], e2, s2);
  return we(n2, [R2]), we(R2, x2), Object.assign(R2.meta, c2, { joint: 1, stateRef: w2 }), At(R2, Nt(M)), o2;
};
var Vt = (e2) => [Te(e2), Pe(((e3, t2, { a: r2 }) => r2), 1)];
var Bt = (e2, t2, r2, n2, o2) => {
  const s2 = Y(e2), i2 = s2 ? L(e2) : Le(), c2 = Le(s2);
  let l2;
  return s2 || (l2 = a({ parent: e2, node: [qe({ from: "stack", target: i2 }), qe({ from: "value", store: 1, target: c2 })], family: { owners: [...new Set([e2, t2, r2].flat())], links: t2 }, meta: { op: o2 }, regional: 1 })), f("sampleSource", c2, i2, n2), [i2, c2, s2, l2];
};
var Lt = (e2, t2, r2, n2) => {
  const a2 = e2[t2];
  a2 && o({ target: a2, params: Array.isArray(a2) ? a2.map((() => r2)) : r2, defer: 1, stack: n2 });
};
var Wt = "23.4.4";
var Ht = (e2) => !e2.node.meta.isCombine || e2.parent && "combine" !== e2.parent.node.meta.op;
var Ut = (e2) => e2;
var Gt = { setDebugTraces: (e2) => {
  zt = e2, e2 && console.log("[effector/debug_traces] Debug traces enabled");
} };

export {
  n,
  a,
  o,
  i,
  p,
  g,
  h,
  b,
  v,
  k,
  S,
  w,
  M,
  x,
  z,
  R,
  A,
  N,
  I,
  O,
  D,
  F,
  q,
  ae,
  he,
  Se,
  Be,
  ft,
  St,
  Mt,
  Wt,
  Gt
};
//# sourceMappingURL=chunk-S5ZKEJOJ.js.map
