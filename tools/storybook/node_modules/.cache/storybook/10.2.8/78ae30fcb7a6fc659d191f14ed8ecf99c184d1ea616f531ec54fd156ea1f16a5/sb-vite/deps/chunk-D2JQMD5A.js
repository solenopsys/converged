import {
  useLayoutEffect2
} from "./chunk-AGADJWPW.js";
import {
  compat_module_exports,
  init_compat_module
} from "./chunk-4PARUNL7.js";
import {
  A,
  d,
  q,
  y
} from "./chunk-AV2RT63R.js";

// ../../node_modules/.bun/@radix-ui+react-use-controllable-state@1.2.2+26a211c426f3f87c/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
init_compat_module();
init_compat_module();

// ../../node_modules/.bun/@radix-ui+react-use-effect-event@0.0.2+26a211c426f3f87c/node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
init_compat_module();
var useReactEffectEvent = compat_module_exports[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = compat_module_exports[" useInsertionEffect ".trim().toString()];

// ../../node_modules/.bun/@radix-ui+react-use-controllable-state@1.2.2+26a211c426f3f87c/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect = compat_module_exports[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = A(prop !== void 0);
    y(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = q(
    (nextValue) => {
      var _a;
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = d(defaultProp);
  const prevValueRef = A(value);
  const onChangeRef = A(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  y(() => {
    var _a;
    if (prevValueRef.current !== value) {
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

export {
  useControllableState
};
//# sourceMappingURL=chunk-D2JQMD5A.js.map
