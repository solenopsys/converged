import "./chunk-5IKWDFCZ.js";

// ../../node_modules/.bun/capsize@2.0.0/node_modules/capsize/dist/capsize.esm.js
function roundTo(number, precision) {
  if (typeof number !== "number") {
    throw new TypeError("Expected value to be a number");
  }
  if (precision === Infinity) {
    return number;
  }
  if (!Number.isInteger(precision)) {
    throw new TypeError("Expected precision to be an integer");
  }
  const isNegative = number < 0;
  const inputNumber = isNegative ? Math.abs(number) : number;
  const power = 10 ** precision;
  const result = Math.round(Number((inputNumber * power).toPrecision(15))) / power;
  return isNegative ? -result : result;
}
function capsize(options) {
  if ("leading" in options && "lineGap" in options) {
    throw new Error("Only a single line height style can be provided. Please pass either `lineGap` OR `leading`.");
  }
  if ("capHeight" in options && "fontSize" in options) {
    throw new Error("Please pass either `capHeight` OR `fontSize`, not both.");
  }
  const {
    fontMetrics
  } = options;
  const capHeightScale = fontMetrics.capHeight / fontMetrics.unitsPerEm;
  let specifiedFontSize;
  let specifiedCapHeight;
  if ("capHeight" in options) {
    specifiedFontSize = options.capHeight / capHeightScale;
    specifiedCapHeight = options.capHeight;
  } else if ("fontSize" in options) {
    specifiedFontSize = options.fontSize;
    specifiedCapHeight = options.fontSize * capHeightScale;
  } else {
    throw new Error("Please pass either `capHeight` OR `fontSize`.");
  }
  let specifiedLineHeight;
  if ("lineGap" in options) {
    specifiedLineHeight = specifiedCapHeight + options.lineGap;
  } else if ("leading" in options) {
    specifiedLineHeight = options.leading;
  }
  return createCss({
    lineHeight: specifiedLineHeight,
    fontSize: specifiedFontSize,
    fontMetrics
  });
}
var PRECISION = 4;
function createCss({
  lineHeight,
  fontSize,
  fontMetrics
}) {
  const toScale = (value) => value / fontSize;
  const absoluteDescent = Math.abs(fontMetrics.descent);
  const capHeightScale = fontMetrics.capHeight / fontMetrics.unitsPerEm;
  const descentScale = absoluteDescent / fontMetrics.unitsPerEm;
  const ascentScale = fontMetrics.ascent / fontMetrics.unitsPerEm;
  const lineGapScale = fontMetrics.lineGap / fontMetrics.unitsPerEm;
  const contentArea = fontMetrics.ascent + fontMetrics.lineGap + absoluteDescent;
  const lineHeightScale = contentArea / fontMetrics.unitsPerEm;
  const lineHeightNormal = lineHeightScale * fontSize;
  const specifiedLineHeightOffset = lineHeight ? (lineHeightNormal - lineHeight) / 2 : 0;
  const leadingTrim = (value) => value - toScale(specifiedLineHeightOffset);
  return {
    fontSize: `${roundTo(fontSize, PRECISION)}px`,
    lineHeight: lineHeight ? `${roundTo(lineHeight, PRECISION)}px` : "normal",
    "::before": {
      content: "''",
      marginBottom: `${roundTo(leadingTrim(ascentScale - capHeightScale + lineGapScale / 2) * -1, PRECISION)}em`,
      display: "table"
    },
    "::after": {
      content: "''",
      marginTop: `${roundTo(leadingTrim(descentScale + lineGapScale / 2) * -1, PRECISION)}em`,
      display: "table"
    }
  };
}
var getCapHeight = ({
  fontSize,
  fontMetrics
}) => roundTo(fontSize * fontMetrics.capHeight / fontMetrics.unitsPerEm, PRECISION);
var capsize_esm_default = capsize;
export {
  capsize_esm_default as default,
  getCapHeight
};
//# sourceMappingURL=capsize.js.map
