import {
  D,
  ae,
  g,
  h,
  o,
  p,
  q
} from "./chunk-S5ZKEJOJ.js";
import {
  compat_module_exports,
  init_compat_module,
  xn
} from "./chunk-4PARUNL7.js";
import {
  y
} from "./chunk-AV2RT63R.js";
import "./chunk-MR3U7D6L.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-5IKWDFCZ.js";

// ../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y3) {
        return x === y3 && (0 !== x || 1 / x === 1 / y3) || x !== x && y3 !== y3;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React = (init_compat_module(), __toCommonJS(compat_module_exports)), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y3) {
        return x === y3 && (0 !== x || 1 / x === 1 / y3) || x !== x && y3 !== y3;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React = (init_compat_module(), __toCommonJS(compat_module_exports)), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// ../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react.mjs
init_compat_module();
var import_with_selector = __toESM(require_with_selector(), 1);
var import_shim = __toESM(require_shim(), 1);
function e(e2, t2) {
  return t2.displayName = e2, t2;
}
function t(e2, t2) {
  const n2 = ae.unit(e2);
  let r2 = {};
  n2 ? r2 = { unit: e2 } : "@@unitShape" in e2 ? "function" == typeof e2["@@unitShape"] ? r2 = e2["@@unitShape"]() : E("expect @@unitShape to be a function") : r2 = e2;
  const o3 = Array.isArray(r2), s2 = xn.useRef({ stale: 1, justSubscribed: 0, scope: t2 }), [u2, c2, a2, i2, l2] = xn.useMemo((() => {
    s2.current.stale = 1;
    const e3 = Array.isArray(r2) ? [] : {}, o4 = [], u3 = [], c3 = [], a3 = [];
    for (const s3 in r2) {
      if (!{}.hasOwnProperty.call(r2, s3)) continue;
      const i3 = r2[s3];
      ae.unit(i3) || E(`expect useUnit ${n2 ? "argument" : `value in key "${s3}"`} to be a unit`), ae.event(i3) || ae.effect(i3) ? (e3[s3] = t2 ? D(i3, { scope: t2 }) : i3, c3.push(s3), a3.push(i3)) : (e3[s3] = null, o4.push(s3), u3.push(i3));
    }
    return [e3, o4, u3, c3, a3];
  }), [s2, t2, ...Object.keys(r2), ...Object.values(r2)]), f2 = xn.useRef({ value: u2, storeKeys: c2, eventKeys: i2, eventValues: l2 }), p3 = xn.useCallback(((e3) => {
    const n3 = s2.current;
    return n3.justSubscribed = 1, q({ unit: a2, fn: () => {
      n3.stale || (n3.stale = 1, e3());
    }, scope: t2, batch: 1 });
  }), [a2, t2, f2, s2]), d2 = xn.useCallback((() => {
    const e3 = f2.current, r3 = s2.current;
    let p4, d3 = 0;
    const y3 = e3.value, m2 = e3.storeKeys, v2 = e3.eventKeys, b = e3.eventValues, h2 = t2 !== r3.scope;
    if (r3.stale || r3.justSubscribed || h2) {
      d3 = !r3.justSubscribed || h2, p4 = o3 ? [...u2] : { ...u2 }, m2.length === c2.length && v2.length === i2.length || (d3 = 1);
      for (let e4 = 0; e4 < c2.length; e4++) {
        const n3 = U(a2[e4], t2), r4 = c2[e4];
        d3 || (d3 = m2.includes(r4) ? y3[r4] !== n3 : 1), p4[r4] = n3;
      }
      for (let e4 = 0; e4 < i2.length; e4++) {
        const t3 = l2[e4], n3 = i2[e4];
        d3 || (d3 = v2.includes(n3) ? b[v2.indexOf(n3)] !== t3 : 1);
      }
    }
    return d3 && (e3.value = p4), e3.storeKeys = c2, e3.eventKeys = i2, e3.eventValues = l2, r3.stale = 0, r3.justSubscribed = !d3, r3.scope = t2, n2 ? e3.value.unit : e3.value;
  }), [p3, a2, l2, t2, f2, s2]);
  return O(p3, d2, d2);
}
function n([e2, t2], n2) {
  let r2, o3, s2, u2, c2 = K;
  t2 ? (r2 = t2, s2 = e2, u2 = []) : { fn: r2, store: s2, keys: u2, defaultValue: o3, updateFilter: c2 = K } = e2, ae.store(s2) || E("useStoreMap expects a store"), Array.isArray(u2) || E("useStoreMap expects an array as keys"), "function" != typeof r2 && E("useStoreMap expects a function");
  const a2 = xn.useCallback(((e3) => q({ unit: s2, fn: e3, scope: n2 })), [s2, n2]), i2 = xn.useCallback((() => U(s2, n2)), [s2, n2]), l2 = xn.useRef(), f2 = xn.useRef(), p3 = xn.useRef(u2);
  return R(a2, i2, i2, ((e3) => {
    if (l2.current !== e3 || !((e4, t3) => {
      if (!e4 || !t3 || e4.length !== t3.length) return 0;
      let n3 = 1;
      for (let r3 = 0; r3 < e4.length; r3++) if (e4[r3] !== t3[r3]) {
        n3 = 0;
        break;
      }
      return n3;
    })(p3.current, u2)) {
      let t3 = r2(e3, u2);
      void 0 === t3 && void 0 !== o3 && (t3 = o3), l2.current = e3, p3.current = u2, void 0 !== t3 && (f2.current = t3);
    }
    return f2.current;
  }), ((e3, t3) => !c2(t3, e3)));
}
function r(e2, n2 = {}, r2) {
  const { open: o3, close: s2, set: u2 } = t({ open: e2.open, close: e2.close, set: e2.set }, r2), c2 = xn.useMemo((() => ({ open: o3, close: s2, set: u2 })), [e2, o3]), a2 = xn.useRef({ value: null, count: 0 });
  M((() => (c2.open(a2.current.value), () => c2.close(a2.current.value))), [c2]), ((e3, t2) => {
    if (e3 === t2) return 1;
    if ("object" == typeof e3 && null !== e3 && "object" == typeof t2 && null !== t2) {
      const n3 = Object.keys(e3), r3 = Object.keys(t2);
      if (n3.length !== r3.length) return 0;
      for (let r4 = 0; r4 < n3.length; r4++) {
        const o4 = n3[r4];
        if (e3[o4] !== t2[o4]) return 0;
      }
      return 1;
    }
    return 0;
  })(a2.current.value, n2) || (a2.current.value = n2, a2.current.count += 1), M((() => {
    c2.set(a2.current.value);
  }), [a2.current.count]);
}
function o2(e2) {
  const t2 = xn.useContext(V);
  return e2 && !t2 && E("No scope found, consider adding <Provider> to app root"), t2;
}
function s(e2, t2) {
  return ((e3, t3) => {
    if (N(1, "useEvent", "useUnit"), !t3) return e3;
    const n2 = ae.unit(e3) || "object" != typeof e3 ? { event: e3 } : e3;
    return xn.useMemo((() => {
      if (ae.unit(e3)) return D(e3, { scope: t3 });
      const n3 = Array.isArray(e3) ? [] : {};
      for (const r2 in e3) n3[r2] = D(e3[r2], { scope: t3 });
      return n3;
    }), [t3, ...Object.keys(n2), ...Object.values(n2)]);
  })(e2, o2(null == t2 ? void 0 : t2.forceScope));
}
function u(e2, t2) {
  return ((e3, t3) => {
    N(1, "useStore", "useUnit"), ae.store(e3) || E("expect useStore argument to be a store");
    const n2 = xn.useCallback(((n3) => q({ unit: e3, fn: n3, scope: t3 })), [e3, t3]), r2 = xn.useCallback((() => U(e3, t3)), [e3, t3]);
    return O(n2, r2, r2);
  })(e2, o2(null == t2 ? void 0 : t2.forceScope));
}
function c(e2, n2) {
  return t(e2, o2(null == n2 ? void 0 : n2.forceScope));
}
function a(e2, t2) {
  return n([e2, t2], o2(null == e2 ? void 0 : e2.forceScope));
}
function i(r2, s2, u2) {
  return ((r3, o3, s3) => {
    let u3, c2, a2, i2 = [];
    "object" == typeof o3 && null !== o3 ? (o3.keys && (i2 = o3.keys), { fn: u3, getKey: c2, placeholder: a2 } = o3) : u3 = o3, ae.store(r3) || E("expect useList first argument to be a store"), "function" != typeof u3 && E("expect useList's renderItem to be a function"), Array.isArray(i2) || E("expect useList's keys to be an array");
    const l2 = xn.useMemo((() => {
      const t2 = e(`${r3.shortName || "Unknown"}.Item`, ((e2) => {
        const { index: t3, keys: o4, keyVal: u4, value: c3 } = e2;
        if (f2.current[1]) return f2.current[0](c3, u4);
        const a3 = n([{ store: r3, keys: [t3, ...o4], fn: (e3, t4) => e3[t4[0]] }], s3);
        return f2.current[0](a3, t3);
      }));
      return xn.memo(t2);
    }), [r3, s3, !!c2]), f2 = xn.useRef([u3, c2]);
    f2.current = [u3, c2];
    const p3 = xn.useMemo((() => i2), i2);
    if (c2) {
      const e2 = t(r3, s3);
      return 0 === e2.length && a2 ? a2 : e2.map(((e3) => {
        const t2 = f2.current[1](e3);
        return xn.createElement(l2, { keyVal: t2, key: t2, keys: p3, value: e3 });
      }));
    }
    {
      const e2 = n([{ store: r3, keys: [r3], fn: (e3) => e3.length }], s3);
      return 0 === e2 && a2 ? a2 : Array.from({ length: e2 }, ((e3, t2) => xn.createElement(l2, { index: t2, key: t2, keys: p3 })));
    }
  })(r2, s2, o2(null == u2 ? void 0 : u2.forceScope));
}
function l(e2, t2 = {}, n2) {
  return r(e2, t2, o2(null == n2 ? void 0 : n2.forceScope));
}
function f() {
  return o2() || null;
}
function p2(t2, n2) {
  function r2(e2) {
    const t3 = xn.useRef(e2), r3 = u(o3);
    M((() => (c2({ props: t3.current, state: o3.getState() }), () => {
      a2({ props: t3.current, state: o3.getState() });
    })), []);
    const s3 = n2(e2, r3);
    return t3.current = e2, s3;
  }
  let o3;
  B("createComponent", "@effector/reflect"), ae.store(t2) ? o3 = t2 : "object" == typeof t2 && null !== t2 ? o3 = h(t2) : E("shape should be a store or object with stores");
  let s2 = "Unknown";
  o3 && o3.shortName && (s2 = o3.shortName);
  const c2 = p(), a2 = p();
  return r2.mounted = c2, r2.unmounted = a2, e(`${s2}.View`, r2);
}
function d(e2) {
  return B("createStoreConsumer", "useUnit"), p2(e2, (({ children: e3 }, t2) => e3(t2)));
}
function y2(e2, t2) {
  const n2 = t2 ? e2 : e2[0];
  var r2;
  ((e3) => {
    if (!e3) throw Error("expect first argument be an object");
  })(I(r2 = n2) || /* @__PURE__ */ ((e3) => "function" == typeof e3)(r2));
  let o3 = n2.or;
  const s2 = n2.and;
  if (s2) {
    const n3 = t2 ? s2 : s2[0];
    if (I(n3) && "and" in n3) {
      const n4 = y2(s2, t2);
      e2 = n4[0], o3 = { ...o3, ...n4[1] };
    } else e2 = s2;
  }
  return [e2, o3];
}
function m(e2, t2) {
  const n2 = t2 && I(r2 = t2[0]) && (r2.and || r2.or) ? t2 : [{ and: t2 }];
  var r2;
  const [[o3, s2], u2] = y2(n2);
  let c2, a2 = {}, i2 = {}, l2 = u2;
  var f2;
  return "string" == typeof o3 ? (i2 = { name: o3 }, I(f2 = s2) && "sid" in f2 || (a2 = s2 || {})) : ((e3) => I(e3) && ("domain" in e3 || "defaultState" in e3 || "name" in e3))(o3) && (i2 = o3, a2 = o3.defaultState || {}, c2 = o3.domain), { hook: e2, domain: c2, defaultState: a2, mainConfig: i2, maybeConfig: l2 };
}
function v(...t2) {
  return (({ domain: t3, defaultState: n2, hook: r2, mainConfig: s2, maybeConfig: u2 }) => {
    function c2(e2) {
      return r2(c2, e2, o2()), null;
    }
    const a2 = z({ or: u2, and: s2 }), i2 = `${t3 ? `${t3.compositeName.fullName}/` : ""}${a2.name || "gate"}`, l2 = p({ name: `${i2}.set`, sid: a2.sid ? `${a2.sid}|set` : void 0 }), f2 = p({ name: `${i2}.open`, sid: a2.sid ? `${a2.sid}|open` : void 0 }), p3 = p({ name: `${i2}.close`, sid: a2.sid ? `${a2.sid}|close` : void 0 }), d2 = g(Boolean(0), { name: `${i2}.status`, serialize: "ignore" }).on(f2, (() => Boolean(1))).on(p3, (() => Boolean(0))), y3 = g(n2, { name: `${i2}.state`, sid: a2.sid }).on(l2, ((e2, t4) => t4)).on(f2, ((e2, t4) => t4)).reset(p3);
    if (t3) {
      const { hooks: e2 } = t3;
      o({ target: [e2.store, e2.store, e2.event, e2.event, e2.event], params: [d2, y3, f2, p3, l2] });
    }
    return c2.open = f2, c2.close = p3, c2.status = d2, c2.state = y3, c2.set = l2, e(`Gate:${i2}`, c2);
  })(m(r, t2));
}
var E = (e2) => {
  throw Error(e2);
};
var M = "undefined" != typeof window ? xn.useLayoutEffect : xn.useEffect;
var N = (e2, t2, n2) => {
  y((() => {
    e2 && console.error(`${t2} is deprecated${n2 ? `, prefer ${n2} instead` : ""}`);
  }), [e2, t2, n2]);
};
var { useSyncExternalStore: O } = import_shim.default;
var { useSyncExternalStoreWithSelector: R } = import_with_selector.default;
var U = (e2, t2) => t2 ? t2.getState(e2) : e2.getState();
var K = (e2, t2) => e2 !== t2;
var V = xn.createContext(null);
var { Provider: L } = V;
var B = (e2, t2) => {
  console.error(`${e2} is deprecated${t2 ? `, use ${t2} instead` : ""}`);
};
var P = (t2) => (B("connect", "useUnit"), (n2) => {
  let r2 = t2;
  return "function" != typeof t2 && (r2 = n2, n2 = t2), e(`Connect(${r2.displayName || r2.name || "Unknown"})`, ((e2) => xn.createElement(r2, { ...e2, ...u(n2) })));
});
var I = (e2) => "object" == typeof e2 && null !== e2;
var z = (e2, t2 = {}) => (I(e2) && (z(e2.or, t2), ((e3) => {
  for (const o3 in e3) r2 = o3, /* @__PURE__ */ ((e4) => void 0 === e4)(n2 = e3[o3]) || "or" === r2 || "and" === r2 || (t2[r2] = n2);
  var n2, r2;
})(e2), z(e2.and, t2)), t2);
export {
  L as Provider,
  P as connect,
  p2 as createComponent,
  v as createGate,
  d as createStoreConsumer,
  s as useEvent,
  l as useGate,
  i as useList,
  f as useProvidedScope,
  u as useStore,
  a as useStoreMap,
  c as useUnit
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=effector-react.js.map
