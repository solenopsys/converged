{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../../../../../../../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/shim/index.js", "../../../../../../../../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../../../../../../../../node_modules/.bun/use-sync-external-store@1.6.0+f4eacebf2041cd4f/node_modules/use-sync-external-store/shim/with-selector.js", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/withDisplayName.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/apiBase.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/scope.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/nossr.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/createComponent.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/createStoreConsumer.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector/config.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector/is.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector/throw.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/createGate.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/throw.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/useDeprecate.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/deprecate.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector-react/connect.ts", "../../../../../../../../../node_modules/.bun/effector-react@23.3.0+0faab4aa7bcec0d2/node_modules/effector-react/effector/collection.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n", "export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n", "import {Store, is, scopeBind, Scope, Unit, Event, createWatch} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\nimport {useDeprecate} from './useDeprecate'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  useDeprecate(true, 'useStore', 'useUnit')\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (fn: () => void) => createWatch({unit: store, fn, scope}),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues, eventKeys, eventValues] =\n    React.useMemo(() => {\n      flagsRef.current.stale = true\n      const shape = Array.isArray(normShape) ? [] : ({} as any)\n      const storeKeys: string[] = []\n      const storeValues: Array<Store<any>> = []\n      const eventKeys: string[] = []\n      const eventValues: Array<Unit<any>> = []\n      for (const key in normShape) {\n        if (!Object.prototype.hasOwnProperty.call(normShape, key)) continue\n        const unit = normShape[key]\n        if (!is.unit(unit)) {\n          const keyMessage = isSingleUnit ? 'argument' : `value in key \"${key}\"`\n          throwError(`expect useUnit ${keyMessage} to be a unit`)\n        }\n        if (is.event(unit) || is.effect(unit)) {\n          shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n          eventKeys.push(key)\n          eventValues.push(unit)\n        } else {\n          shape[key] = null\n          storeKeys.push(key)\n          storeValues.push(unit as Store<any>)\n        }\n      }\n      return [shape, storeKeys, storeValues, eventKeys, eventValues]\n    }, [\n      flagsRef,\n      scope,\n      ...Object.keys(normShape),\n      ...Object.values(normShape),\n    ])\n  const stateRef = React.useRef({\n    value: eventsShape,\n    storeKeys,\n    eventKeys,\n    eventValues,\n  })\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      return createWatch({unit: storeValues, fn: cbCaller, scope, batch: true})\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldStoreKeys = state.storeKeys\n    const oldEventKeys = state.eventKeys\n    const oldEventValues = state.eventValues\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (\n        oldStoreKeys.length !== storeKeys.length ||\n        oldEventKeys.length !== eventKeys.length\n      ) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldStoreKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n      for (let i = 0; i < eventKeys.length; i++) {\n        const updatedValue = eventValues[i]\n        const key = eventKeys[i]\n        if (!changed) {\n          if (!oldEventKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldEventValues[oldEventKeys.indexOf(key)] !== updatedValue\n          }\n        }\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    state.eventKeys = eventKeys\n    state.eventValues = eventValues\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, eventValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (fn: () => void) => createWatch({unit: store, fn, scope}),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useUnitBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  useDeprecate(true, 'useEvent', 'useUnit')\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n", "import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n", "import {Event, Store, Scope} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {getScope} from './scope'\nimport type {Gate} from './index.h'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  opts?: {forceScope?: boolean},\n) {\n  return useGateBase(GateComponent, props, getScope(opts?.forceScope))\n}\n\nexport function useProvidedScope(): Scope | null {\n  const scope = getScope() || null\n  return scope\n}\n", "import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './nossr'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\nimport {deprecate} from './deprecate'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  deprecate('createComponent', '@effector/reflect')\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n", "import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\nimport {deprecate} from './deprecate'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  deprecate('createStoreConsumer', 'useUnit')\n  return createComponent(store, ({children}, state) => children(state))\n}\n", "import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n", "export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    assert(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\" is not supported, use createStore/createEvent instead\"`,\n    ),\n  )\n", "export function assert(\n  condition: unknown,\n  message: string,\n  errorTitle?: string,\n): asserts condition {\n  if (!condition)\n    throw Error(`${errorTitle ? errorTitle + ': ' : ''}${message}`)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n  errorTitle?: string,\n) =>\n  !condition &&\n  console.error(\n    `${errorTitle ? errorTitle + ': ' : ''}${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n", "import {createStore, launch, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {useGateBase} from './apiBase'\nimport {getScope} from './scope'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function createGateImplementation<State>({\n  domain,\n  defaultState,\n  hook: useGateHook,\n  mainConfig,\n  maybeConfig,\n}: {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n}): Gate<State> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: mainConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config.name || 'gate'\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<State>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<State>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n    sid: config.sid,\n  })\n    .on(set, (_, state) => state)\n    .on(open, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props, getScope())\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\n\nconst isPluginConfig = (config: Record<string, any> | string) =>\n  isObject(config) && 'sid' in config\n\nconst isGateConfig = (config: Record<string, any> | string) =>\n  isObject(config) &&\n  ('domain' in config || 'defaultState' in config || 'name' in config)\n\nconst isStructuredConfig = (arg: unknown) =>\n  isObject(arg) && (arg.and || arg.or)\n\nexport function processCreateGateConfig<State>(\n  hook: typeof useGateBase,\n  args: unknown[],\n): {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n} {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n  const [[nameOrConfig, defaultStateOrConfig], metadata] =\n    processArgsToConfig(universalConfig)\n\n  let domain\n  let defaultState = {}\n  let mainConfig = {}\n  let maybeConfig = metadata\n\n  if (typeof nameOrConfig === 'string') {\n    mainConfig = {name: nameOrConfig}\n    if (isPluginConfig(defaultStateOrConfig)) {\n      // maybeConfig = defaultStateOrConfig\n    } else {\n      defaultState = defaultStateOrConfig || {}\n    }\n  } else if (isGateConfig(nameOrConfig)) {\n    mainConfig = nameOrConfig\n    defaultState = nameOrConfig.defaultState || {}\n    domain = nameOrConfig.domain\n  }\n  return {\n    hook,\n    domain,\n    defaultState,\n    mainConfig,\n    maybeConfig,\n  }\n}\n\nexport function createGate<Props>(...args: unknown[]): Gate<Props> {\n  return createGateImplementation<Props>(\n    processCreateGateConfig(useGateBase, args),\n  )\n}\n", "export const throwError = (message: string) => {\n  throw Error(message)\n}\n", "import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n", "import {useEffect} from 'react'\n\nexport const useDeprecate = (\n  cond: boolean,\n  subject: string,\n  useInstead?: string,\n) => {\n  useEffect(() => {\n    if (cond) {\n      console.error(\n        `${subject} is deprecated${\n          useInstead ? `, prefer ${useInstead} instead` : ''\n        }`,\n      )\n    }\n  }, [cond, subject, useInstead])\n}\n", "export const deprecate = (method: string, suggestion?: string) => {\n  const suggestionMessage = suggestion ? `, use ${suggestion} instead` : ''\n  console.error(`${method} is deprecated${suggestionMessage}`)\n}\n", "import React from 'react'\n\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\nimport {deprecate} from './deprecate'\n\nexport const connect = <State>(Component: React.ComponentType<any>) => {\n  deprecate('connect', 'useUnit')\n  return (store: Store<State>) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...useStore(store)}),\n    )\n  }\n}\n", "export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n"],
  "mappings": "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",
  "names": ["y", "y", "args", "args", "withDisplayName", "name", "Component", "displayName", "useUnitBase", "shape", "scope", "isSingleUnit", "is", "unit", "normShape", "throwError", "isList", "Array", "isArray", "flagsRef", "React", "useRef", "stale", "justSubscribed", "eventsShape", "storeKeys", "storeValues", "eventKeys", "eventValues", "useMemo", "current", "key", "Object", "hasOwnProperty", "call", "event", "effect", "scopeBind", "push", "keys", "values", "stateRef", "value", "subscribe", "useCallback", "cb", "flags", "createWatch", "fn", "batch", "read", "state", "resultValue", "changed", "oldVal", "oldStoreKeys", "oldEventKeys", "oldEventValues", "scopeChanged", "length", "i", "updatedValue", "stateReader", "includes", "indexOf", "useSyncExternalStore", "useStoreMapBase", "configOrStore", "separateFn", "defaultValue", "store", "updateFilter", "basicUpdateFilter", "valueRef", "keysRef", "useSyncExternalStoreWithSelector", "a", "b", "isEqual", "result", "update", "useGateBase", "GateComponent", "props", "open", "close", "set", "ForkedGate", "propsRef", "count", "useIsomorphicLayoutEffect", "aKeys", "bKeys", "getScope", "forceScope", "useContext", "ScopeContext", "useEvent", "opts", "eventObject", "useDeprecate", "events", "useStore", "useUnit", "useStoreMap", "useList", "list", "renderItem", "getKey", "placeholder", "Item", "shortName", "index", "keyVal", "fnRef", "item", "memo", "keysSelfMemo", "listItems", "map", "createElement", "from", "_", "useGate", "useProvidedScope", "createComponent", "renderProp", "RenderComponent", "mounted", "getState", "unmounted", "deprecate", "combine", "storeName", "createEvent", "createStoreConsumer", "children", "processArgsToConfig", "singleArgument", "rawConfig", "condition", "Error", "isObject", "metadata", "or", "childConfig", "and", "unwrappedNestedValue", "nested", "processCreateGateConfig", "hook", "universalConfig", "arg", "nameOrConfig", "defaultStateOrConfig", "domain", "defaultState", "mainConfig", "maybeConfig", "config", "createGate", "useGateHook", "flattenConfig", "fullName", "compositeName", "sid", "undefined", "status", "createStore", "Boolean", "serialize", "on", "reset", "hooks", "launch", "target", "params", "message", "window", "useLayoutEffect", "useEffect", "cond", "subject", "useInstead", "console", "error", "upd", "oldValue", "createContext", "Provider", "method", "suggestion", "connect", "View", "part", "obj", "field"]
}
